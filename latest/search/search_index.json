{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kiara plugin:","text":"<p>This package contains a set of commonly used/useful modules, pipelines, types and metadata schemas for kiara.</p>"},{"location":"#description","title":"Description","text":"<p>Network-related data-types, modules and pipelines for kiara.</p>"},{"location":"#package-content","title":"Package content","text":""},{"location":"#data_types","title":"data_types","text":"<ul> <li><code>network_data</code>: Data that can be assembled into a graph.</li> </ul>"},{"location":"#module_types","title":"module_types","text":"<ul> <li> <p><code>network_data.filters</code>: -- n/a --</p> </li> <li> <p><code>create.network_data</code>: -- n/a --</p> </li> <li> <p><code>assemble.network_data</code>: Create a 'network_data' instance from one or two tables.</p> </li> </ul>"},{"location":"#kiara_model_types","title":"kiara_model_types","text":"<ul> <li> <p><code>network_graph_properties</code>: Network data stats.</p> </li> <li> <p><code>instance.network_data</code>: A flexible, graph-type agnostic wrapper class for network datasets.</p> </li> <li> <p><code>metadata.network_node_attribute</code>: -- n/a --</p> </li> <li> <p><code>metadata.network_edge_attribute</code>: -- n/a --</p> </li> </ul>"},{"location":"#operations","title":"operations","text":"<ul> <li> <p><code>assemble.network_data</code>: Create a 'network_data' instance from one or two tables.</p> </li> <li> <p><code>create.network_data.from.file</code>: Create a table from a file, trying to auto-determine the format of said file.</p> </li> <li> <p><code>network_data_filter.select_component</code>: -- n/a --</p> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://DHARPA-Project.github.io/kiara_plugin.network_analysis</li> <li>Code: https://github.com/DHARPA-Project/kiara_plugin.network_analysis</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Usage</li> <li>Package contents</li> <li>API reference</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>TO BE DONE</p>"},{"location":"info/SUMMARY/","title":"SUMMARY","text":"<ul> <li>data_types</li> <li>module_types</li> <li>kiara_model_types</li> <li>operations</li> </ul>"},{"location":"info/data_types/","title":"data_types","text":""},{"location":"info/data_types/#kiara_info.data_types.network_data","title":"<code>network_data</code>","text":"type_name network_data The registered name for this item type. documentation <p>Data that can be assembled into a graph.</p> <p>This data type extends the 'tables' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'.</p> Edges <p>The 'edges' table contains the following columns:</p> <p>_edge_id:</p> <p>The unique id for the edge.</p> <p>_source:</p> <p>The node id of the source for an edge.</p> <p>_target:</p> <p>The node id of the target for an edge.</p> <p>_count_dup_directed:</p> <p>The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as directed multi graph.</p> <p>_idx_dup_directed:</p> <p>A unique index for this edge within its set of duplicates, if the network_data is interpreted as directed multi graph.</p> <p>This is a unique integer identifier in combination with (_source/_target), counting up from 1. The order of the edges within this set is not guaranteed.</p> <p>_count_dup_undirected:</p> <p>The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as undirected multi graph.</p> <p>_idx_dup_undirected:</p> <p>A unique index for this edge within its set of duplicates, if the network_data is interpreted as undirected multi graph.</p> <p>This is a unique integer identifier in combination with (_source/_target), counting up from 1. The order of the edges within this set is not guaranteed.</p> Nodes <p>The 'nodes' table contains the following columns:</p> <p>_node_id:</p> <p>The unique id for the node.</p> <p>This is a unique integer identifier (counting up from 0) and is automatically generated by kiara, for each <code>network_data</code> value.</p> <p>_label:</p> <p>The label for the node.</p> <p>This is a (potentially non-unique) (ideally) human meaningful lable for the node, mostly used in visualizations. Depending on how the 'network_data' was created, this could be a name, title, etc. If no such label was available or specified by the user, the node id will be used as label.</p> <p>_count_edges:</p> <p>The number of edges that are connected to this node if the network_data is interpreted as a non-multi graph</p> <p>Both incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs. .</p> <p>_count_edges_multi:</p> <p>The number of edges that are connected to this node if the network_data is interpreted as a multi graph</p> <p>Both incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs.</p> <p>_in_edges:</p> <p>The number of incoming edges that are connected to this node if the network_data is interpreted as a non-multi graph.</p> <p>_in_edges_multi:</p> <p>The number of incoming edges that are connected to this node if the network_data is interpreted as a multi graph.</p> <p>_out_edges:</p> <p>The number of outgoing edges that are connected to this node if the network_data is interpreted as a non-multi graph.</p> <p>_out_edges_multi:</p> <p>The number of outgoing edges that are connected to this node if the network_data is interpreted as a multi graph.</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkDataType The name of the Python class. python_module_name kiara_plugin.network_analysis.data_types The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.data_types.NetworkDataType The full class namespace. The python class that implements this module type. value_cls python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class of the value itself. data_type_config_cls python_class_name DataTypeConfig The name of the Python class. python_module_name kiara.data_types The name of the Python module this class lives in. full_name kiara.data_types.DataTypeConfig The full class namespace. The python class holding the schema for configuring this type. lineage <ul> <li>     network_data   </li> <li>     tables   </li> <li>     any   </li> </ul> This types lineage. qualifier_profiles A map of qualifier profiles for this data types. supported_properties group_title Metadata models for type 'network_data' The group alias. item_infos network_graph_properties type_name network_data The registered name for this item type. documentation <p>Network data stats.</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkGraphProperties The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkGraphProperties The full class namespace. The python class that implements this module type. metadata_schema $defs ComponentProperties description Properties of a connected component. properties component_id description The id of the component. title Component Id type integer number_of_nodes description The number of nodes in the component. title Number Of Nodes type integer number_of_associated_edge_rows description The number of edge rows associated to the component. title Number Of Associated Edge Rows type integer required <ul> <li>     component_id   </li> <li>     number_of_nodes   </li> <li>     number_of_associated_edge_rows   </li> </ul> title ComponentProperties type object GraphProperties description Properties of graph data, if interpreted as a specific graph type. properties number_of_edges description The number of edges. title Number Of Edges type integer parallel_edges default 0 description The number of parallel edges (if 'multi' graph type). title Parallel Edges type integer required <ul> <li>     number_of_edges   </li> </ul> title GraphProperties type object additionalProperties False description Network data stats. properties number_of_nodes description Number of nodes in the network graph. title Number Of Nodes type integer properties_by_graph_type additionalProperties $ref #/$defs/GraphProperties description Properties of the network data, by graph type. propertyNames enum <ul> <li>     directed   </li> <li>     undirected   </li> <li>     undirected_multi   </li> <li>     directed_multi   </li> </ul> title Properties By Graph Type type object number_of_self_loops description Number of edges where source and target point to the same node. title Number Of Self Loops type integer number_of_components description Number of connected components in the network graph. title Number Of Components type integer components additionalProperties $ref #/$defs/ComponentProperties description Properties of the components of the network graph. title Components type object required <ul> <li>     number_of_nodes   </li> <li>     properties_by_graph_type   </li> <li>     number_of_self_loops   </li> <li>     number_of_components   </li> <li>     components   </li> </ul> title NetworkGraphProperties type object The (json) schema for this metadata value. The value metadata info instances for each type. type_name value_metadata The supported property types for this data type."},{"location":"info/kiara_model_types/","title":"kiara_model_types","text":""},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.network_graph_properties","title":"<code>network_graph_properties</code>","text":"type_name network_graph_properties The registered name for this item type. documentation <p>Network data stats.</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkGraphProperties The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkGraphProperties The full class namespace. The python class that implements this module type. metadata_schema $defs ComponentProperties description Properties of a connected component. properties component_id description The id of the component. title Component Id type integer number_of_nodes description The number of nodes in the component. title Number Of Nodes type integer number_of_associated_edge_rows description The number of edge rows associated to the component. title Number Of Associated Edge Rows type integer required <ul> <li>     component_id   </li> <li>     number_of_nodes   </li> <li>     number_of_associated_edge_rows   </li> </ul> title ComponentProperties type object GraphProperties description Properties of graph data, if interpreted as a specific graph type. properties number_of_edges description The number of edges. title Number Of Edges type integer parallel_edges default 0 description The number of parallel edges (if 'multi' graph type). title Parallel Edges type integer required <ul> <li>     number_of_edges   </li> </ul> title GraphProperties type object additionalProperties False description Network data stats. properties number_of_nodes description Number of nodes in the network graph. title Number Of Nodes type integer properties_by_graph_type additionalProperties $ref #/$defs/GraphProperties description Properties of the network data, by graph type. propertyNames enum <ul> <li>     directed   </li> <li>     undirected   </li> <li>     undirected_multi   </li> <li>     directed_multi   </li> </ul> title Properties By Graph Type type object number_of_self_loops description Number of edges where source and target point to the same node. title Number Of Self Loops type integer number_of_components description Number of connected components in the network graph. title Number Of Components type integer components additionalProperties $ref #/$defs/ComponentProperties description Properties of the components of the network graph. title Components type object required <ul> <li>     number_of_nodes   </li> <li>     properties_by_graph_type   </li> <li>     number_of_self_loops   </li> <li>     number_of_components   </li> <li>     components   </li> </ul> title NetworkGraphProperties type object The (json) schema for this model data."},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.instance.network_data","title":"<code>instance.network_data</code>","text":"type_name instance.network_data The registered name for this item type. documentation <p>A flexible, graph-type agnostic wrapper class for network datasets.</p> <p>This class provides a unified interface for working with network data that can represent any type of graph structure: directed, undirected, simple, or multi-graphs. The design philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.</p> <p>Design Philosophy:</p> <ul> <li>Graph Type Agnostic: Supports all graph types (directed/undirected, simple/multi) within the same data structure without requiring type-specific conversions</li> <li>Efficient Storage: Uses Apache Arrow tables for high-performance columnar storage</li> <li>Flexible Querying: Provides SQL-based querying capabilities alongside programmatic access</li> <li>Seamless Export: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future</li> <li>Metadata Rich: Automatically computes and stores graph statistics and properties</li> </ul> <p>Internal Structure: The network data is stored as two Arrow tables:</p> <ul> <li>nodes table: Contains node information with required columns '_node_id' (int) and '_label' (str)</li> <li>edges table: Contains edge information with required columns '_source' (int) and '_target' (int)</li> </ul> <p>Additional computed columns (prefixed with '_') provide graph statistics for different interpretations:</p> <ul> <li>Degree counts for directed/undirected graphs</li> <li>Multi-edge counts and indices</li> <li>Centrality measures</li> </ul> <p>Graph Type Support:</p> <ul> <li>Simple Graphs: Single edges between node pairs</li> <li>Multi-graphs: Multiple edges between the same node pairs</li> <li>Directed Graphs: One-way edges with source \u2192 target semantics</li> <li>Undirected Graphs: Bidirectional edges</li> <li>Mixed Types: The same data can be interpreted as different graph types</li> </ul> <p>Note: Column names prefixed with '_' have internal meaning and are automatically computed. Original attributes from source data are stored without the prefix.</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkData The name of the Python class. python_module_name kiara_plugin.network_analysis.models The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.NetworkData The full class namespace. The python class that implements this module type. metadata_schema $defs KiaraTable additionalProperties False description A wrapper class to manage tabular data in a memory efficient way. properties data_path anyOf <ul> <li> type string </li> <li> type null </li> </ul> default None description The path to the (feather) file backing this array. title Data Path title KiaraTable type object additionalProperties False description A flexible, graph-type agnostic wrapper class for network datasets.  This class provides a unified interface for working with network data that can represent any type of graph structure: directed, undirected, simple, or multi-graphs. The design philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.  **Design Philosophy:** - **Graph Type Agnostic**: Supports all graph types (directed/undirected, simple/multi)   within the same data structure without requiring type-specific conversions - **Efficient Storage**: Uses Apache Arrow tables for high-performance columnar storage - **Flexible Querying**: Provides SQL-based querying capabilities alongside programmatic access - **Seamless Export**: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future - **Metadata Rich**: Automatically computes and stores graph statistics and properties  **Internal Structure:** The network data is stored as two Arrow tables: - **nodes table**: Contains node information with required columns '_node_id' (int) and '_label' (str) - **edges table**: Contains edge information with required columns '_source' (int) and '_target' (int)  Additional computed columns (prefixed with '_') provide graph statistics for different interpretations: - Degree counts for directed/undirected graphs - Multi-edge counts and indices - Centrality measures  **Graph Type Support:** - **Simple Graphs**: Single edges between node pairs - **Multi-graphs**: Multiple edges between the same node pairs - **Directed Graphs**: One-way edges with source \u2192 target semantics - **Undirected Graphs**: Bidirectional edges - **Mixed Types**: The same data can be interpreted as different graph types  **Note:** Column names prefixed with '_' have internal meaning and are automatically computed. Original attributes from source data are stored without the prefix. properties tables additionalProperties $ref #/$defs/KiaraTable description A dictionary of tables, with the table names as keys. title Tables type object required <ul> <li>     tables   </li> </ul> title NetworkData type object The (json) schema for this model data."},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.metadata.network_node_attribute","title":"<code>metadata.network_node_attribute</code>","text":"type_name metadata.network_node_attribute The registered name for this item type. documentation <p>-- n/a --</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkNodeAttributeMetadata The name of the Python class. python_module_name kiara_plugin.network_analysis.models.metadata The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata The full class namespace. The python class that implements this module type. metadata_schema $defs DocumentationMetadataModel additionalProperties False description Documentation about a resource. properties description default -- n/a -- description Short description of the item. title Description type string doc anyOf <ul> <li> type string </li> <li> type null </li> </ul> default None description Detailed documentation of the item (in markdown). title Doc title Documentation type object additionalProperties False properties doc $ref #/$defs/DocumentationMetadataModel description Explanation what this attribute is about. computed_attribute default False description Whether this is the default attribute that is always automatically added by kiara. title Computed Attribute type boolean title NetworkNodeAttributeMetadata type object The (json) schema for this model data."},{"location":"info/kiara_model_types/#kiara_info.kiara_model_types.metadata.network_edge_attribute","title":"<code>metadata.network_edge_attribute</code>","text":"type_name metadata.network_edge_attribute The registered name for this item type. documentation <p>-- n/a --</p> Documentation for the item. authors <ul> <li>Markus Binsteiner ( markus@frkl.dev )</li> </ul> Information about authorship for the item. context tags network_analysis labels <ul> <li>package: kiara_plugin.network_analysis</li> </ul> references <ul> <li>source_repo: The module package git repository.</li> <li>documentation: The url for the module package documentation.</li> </ul> Generic properties of this item (description, tags, labels, references, ...). python_class python_class_name NetworkEdgeAttributeMetadata The name of the Python class. python_module_name kiara_plugin.network_analysis.models.metadata The name of the Python module this class lives in. full_name kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata The full class namespace. The python class that implements this module type. metadata_schema $defs DocumentationMetadataModel additionalProperties False description Documentation about a resource. properties description default -- n/a -- description Short description of the item. title Description type string doc anyOf <ul> <li> type string </li> <li> type null </li> </ul> default None description Detailed documentation of the item (in markdown). title Doc title Documentation type object additionalProperties False properties doc $ref #/$defs/DocumentationMetadataModel description Explanation what this attribute is about. computed_attribute default False description Whether this is the computed attribute that is automatically added by kiara. title Computed Attribute type boolean title NetworkEdgeAttributeMetadata type object The (json) schema for this model data."},{"location":"info/module_types/","title":"module_types","text":""},{"location":"info/module_types/#kiara_info.module_types.network_data.filters","title":"<code>network_data.filters</code>","text":"Documentation <p>-- n/a --</p> Author(s) <li>     Markus Binsteiner &lt;markus@frkl.dev&gt; </li> Context Tags network_analysis Labels package References <ul> <li>source_repo</li> <li>documentation</li> </ul> Python class  kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule  Module config Field Type Description Required Default constants object Value constants for this module. defaults object Value defaults for this module. filter_name string The name of the filter. \u2713"},{"location":"info/module_types/#kiara_info.module_types.create.network_data","title":"<code>create.network_data</code>","text":"Documentation <p>-- n/a --</p> Author(s) <li>     Markus Binsteiner &lt;markus@frkl.dev&gt; </li> <li>     Lena Jaskov &lt;helena.jaskov@uni.lu&gt; </li> <li>     Markus Binsteiner &lt;markus@frkl.io&gt; </li> Context Tags network_analysis Labels package References <ul> <li>source_repo</li> <li>documentation</li> </ul> Python class  kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule  Module config Field Type Description Required Default constants object Value constants for this module. defaults object Value defaults for this module. source_type string The value type of the source value. \u2713 target_type string The value type of the target. \u2713 ignore_errors boolean Whether to ignore convert errors and omit the failed items."},{"location":"info/module_types/#kiara_info.module_types.assemble.network_data","title":"<code>assemble.network_data</code>","text":"Documentation <p>Create a 'network_data' instance from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> <p>If no <code>source_column_name</code> (and/or <code>target_column_name</code>) is provided, kiara will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.</p> Author(s) <li>     Markus Binsteiner &lt;markus@frkl.dev&gt; </li> <li>     Lena Jaskov &lt;helena.jaskov@uni.lu&gt; </li> <li>     Markus Binsteiner &lt;markus@frkl.io&gt; </li> Context Tags network_analysis Labels package References <ul> <li>source_repo</li> <li>documentation</li> </ul> Python class  kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule  Module config Field Type Description Required Default constants object Value constants for this module. defaults object Value defaults for this module. node_id_column_aliases array Alias strings to test (in order) for auto-detecting the node id column. label_column_aliases array Alias strings to test (in order) for auto-detecting the node label column. source_column_aliases array Alias strings to test (in order) for auto-detecting the source column. target_column_aliases array Alias strings to test (in order) for auto-detecting the target column."},{"location":"info/operations/","title":"operations","text":""},{"location":"info/operations/#kiara_info.operations.assemble.network_data","title":"<code>assemble.network_data</code>","text":"Documentation <p>Create a 'network_data' instance from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> <p>If no <code>source_column_name</code> (and/or <code>target_column_name</code>) is provided, kiara will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.</p> Inputs field name type description required default edges table A table that contains the edges data. yes source_column string The name of the source column name in the edges table. no target_column string The name of the target column name in the edges table. no edges_column_map dict An optional map of original column name to desired. no nodes table A table that contains the nodes data. no id_column string The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table). no label_column string The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label. no nodes_column_map dict An optional map of original column name to desired. no Outputs field name type description required default network_data network_data The network/graph data. yes"},{"location":"info/operations/#kiara_info.operations.create.network_data.from.file","title":"<code>create.network_data.from.file</code>","text":"Documentation <p>Create a table from a file, trying to auto-determine the format of said file.</p> <p>Supported file formats (at the moment):</p> <ul> <li>gml</li> <li>gexf</li> <li>graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)</li> <li>pajek</li> <li>leda</li> <li>graph6</li> <li>sparse6</li> </ul> Inputs field name type description required default file file The source value (of type 'file'). yes Outputs field name type description required default network_data network_data The result value (of type 'network_data'). yes"},{"location":"info/operations/#kiara_info.operations.network_data_filter.select_component","title":"<code>network_data_filter.select_component</code>","text":"Documentation <p>-- n/a --</p> Inputs field name type description required default value network_data A value of type 'network_data'. yes component_id integer The id of the componen to select. no 0 Outputs field name type description required default value network_data The filtered value. yes"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kiara_plugin<ul> <li>network_analysis<ul> <li>data_types</li> <li>defaults</li> <li>models<ul> <li>metadata</li> </ul> </li> <li>modules<ul> <li>create</li> <li>filter</li> </ul> </li> <li>pipelines</li> <li>utils<ul> <li>notebooks<ul> <li>jupyter</li> <li>marimo</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/kiara_plugin/network_analysis/__init__/","title":"network_analysis","text":"<p>Top-level package for kiara_plugin.network_analysis.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': __author__, 'email': __email__}], 'description': 'Kiara modules for: network_analysis', 'references': {'source_repo': {'desc': 'The module package git repository.', 'url': 'https://github.com/DHARPA-Project/kiara_plugin.network_analysis'}, 'documentation': {'desc': 'The url for the module package documentation.', 'url': 'https://DHARPA-Project.github.io/kiara_plugin.network_analysis/'}}, 'tags': ['network_analysis'], 'labels': {'package': 'kiara_plugin.network_analysis'}}</code>  <code>module-attribute</code>","text":"<p>Kiara metadata for the <code>kiara_plugin.network_analysis</code> module.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_modules","title":"<code>find_modules: KiaraEntryPointItem = (find_kiara_modules_under, 'kiara_plugin.network_analysis.modules')</code>  <code>module-attribute</code>","text":"<p>Entry point to discover all <code>kiara</code> modules for this plugin.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_model_classes","title":"<code>find_model_classes: KiaraEntryPointItem = (find_kiara_model_classes_under, 'kiara_plugin.network_analysis.models')</code>  <code>module-attribute</code>","text":"<p>Entry point to discover all <code>kiara</code> model classes for this plugin.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_data_types","title":"<code>find_data_types: KiaraEntryPointItem = (find_data_types_under, 'kiara_plugin.network_analysis.data_types')</code>  <code>module-attribute</code>","text":"<p>Entry point to discover all <code>kiara</code> data types for this plugin.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.find_pipelines","title":"<code>find_pipelines: KiaraEntryPointItem = (find_pipeline_base_path_for_module, 'kiara_plugin.network_analysis.pipelines', KIARA_METADATA)</code>  <code>module-attribute</code>","text":"<p>Entry point to discover all <code>kiara</code> pipelines for this plugin.</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType","title":"<code>NetworkDataType</code>","text":"<p>               Bases: <code>TablesType</code></p> <p>Data that can be assembled into a graph.</p> <p>This data type extends the 'tables' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'.</p> Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>class NetworkDataType(TablesType):\n    \"\"\"Data that can be assembled into a graph.\n\n    This data type extends the 'tables' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges',\n    and one called 'nodes'.\n    \"\"\"\n\n    _data_type_name: ClassVar[str] = \"network_data\"\n    _cached_doc: ClassVar[Union[str, None]] = None\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return NetworkData  # type: ignore\n\n    @classmethod\n    def type_doc(cls) -&gt; str:\n        if cls._cached_doc:\n            return cls._cached_doc\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        edge_properties = {}\n        edge_properties[EDGE_ID_COLUMN_NAME] = EDGE_ID_COLUMN_METADATA.doc.full_doc\n        edge_properties[SOURCE_COLUMN_NAME] = EDGE_SOURCE_COLUMN_METADATA.doc.full_doc\n        edge_properties[TARGET_COLUMN_NAME] = EDGE_TARGET_COLUMN_METADATA.doc.full_doc\n        edge_properties[COUNT_DIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_DIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n\n        properties_node = {}\n        properties_node[NODE_ID_COLUMN_NAME] = NODE_ID_COLUMN_METADATA.doc.full_doc\n        properties_node[LABEL_COLUMN_NAME] = NODE_LABEL_COLUMN_METADATA.doc.full_doc\n        properties_node[CONNECTIONS_COLUMN_NAME] = (\n            NODE_COUNT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[CONNECTIONS_MULTI_COLUMN_NAME] = (\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n\n        edge_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in edge_properties.items()\n        )\n        node_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in properties_node.items()\n        )\n\n        doc = cls.__doc__\n        doc_tables = f\"\"\"\n\n## Edges\nThe 'edges' table contains the following columns:\n\n{edge_properties_str}\n\n## Nodes\n\nThe 'nodes' table contains the following columns:\n\n{node_properties_str}\n\n\"\"\"\n\n        cls._cached_doc = f\"{doc}\\n\\n{doc_tables}\"\n        return cls._cached_doc\n\n    def parse_python_obj(self, data: Any) -&gt; NetworkData:\n        if isinstance(data, KiaraTables):\n            if EDGES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n                )\n\n            if NODES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n                )\n\n            # return NetworkData(\n            #     tables={\n            #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n            #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n            #     },\n            #\n            # )\n            return NetworkData.create_network_data(\n                edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n                nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n                augment_tables=False,\n            )\n\n        if not isinstance(data, NetworkData):\n            raise KiaraException(\n                f\"Can't parse object to network data: invalid type '{type(data)}'.\"\n            )\n\n        return data\n\n    def _validate(cls, value: Any) -&gt; None:\n        if not isinstance(value, NetworkData):\n            raise ValueError(\n                f\"Invalid type '{type(value)}': must be of 'NetworkData' (or a sub-class).\"\n            )\n\n        network_data: NetworkData = value\n\n        table_names = network_data.table_names\n        if EDGES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{EDGES_TABLE_NAME}'.\"\n            )\n        if NODES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{NODES_TABLE_NAME}'.\"\n            )\n\n        edges_columns = network_data.edges.column_names\n        if SOURCE_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{SOURCE_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n        if TARGET_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{TARGET_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n\n        nodes_columns = network_data.nodes.column_names\n        if NODE_ID_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{NODE_ID_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n        if LABEL_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{LABEL_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n\n    def pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        network_data: NetworkData = value.data\n\n        result: List[Any] = [\"\"]\n\n        nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n        nodes_pretty = nodes_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n        result.append(nodes_pretty)\n\n        edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n        edges_pretty = edges_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n        result.append(edges_pretty)\n\n        return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return NetworkData  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType.type_doc","title":"<code>type_doc() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>    @classmethod\n    def type_doc(cls) -&gt; str:\n        if cls._cached_doc:\n            return cls._cached_doc\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        edge_properties = {}\n        edge_properties[EDGE_ID_COLUMN_NAME] = EDGE_ID_COLUMN_METADATA.doc.full_doc\n        edge_properties[SOURCE_COLUMN_NAME] = EDGE_SOURCE_COLUMN_METADATA.doc.full_doc\n        edge_properties[TARGET_COLUMN_NAME] = EDGE_TARGET_COLUMN_METADATA.doc.full_doc\n        edge_properties[COUNT_DIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_DIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n\n        properties_node = {}\n        properties_node[NODE_ID_COLUMN_NAME] = NODE_ID_COLUMN_METADATA.doc.full_doc\n        properties_node[LABEL_COLUMN_NAME] = NODE_LABEL_COLUMN_METADATA.doc.full_doc\n        properties_node[CONNECTIONS_COLUMN_NAME] = (\n            NODE_COUNT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[CONNECTIONS_MULTI_COLUMN_NAME] = (\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n\n        edge_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in edge_properties.items()\n        )\n        node_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in properties_node.items()\n        )\n\n        doc = cls.__doc__\n        doc_tables = f\"\"\"\n\n## Edges\nThe 'edges' table contains the following columns:\n\n{edge_properties_str}\n\n## Nodes\n\nThe 'nodes' table contains the following columns:\n\n{node_properties_str}\n\n\"\"\"\n\n        cls._cached_doc = f\"{doc}\\n\\n{doc_tables}\"\n        return cls._cached_doc\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; NetworkData</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; NetworkData:\n    if isinstance(data, KiaraTables):\n        if EDGES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n            )\n\n        if NODES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n            )\n\n        # return NetworkData(\n        #     tables={\n        #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n        #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n        #     },\n        #\n        # )\n        return NetworkData.create_network_data(\n            edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n            nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n            augment_tables=False,\n        )\n\n    if not isinstance(data, NetworkData):\n        raise KiaraException(\n            f\"Can't parse object to network data: invalid type '{type(data)}'.\"\n        )\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkDataType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    network_data: NetworkData = value.data\n\n    result: List[Any] = [\"\"]\n\n    nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n    nodes_pretty = nodes_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n    result.append(nodes_pretty)\n\n    edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n    edges_pretty = edges_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n    result.append(edges_pretty)\n\n    return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData","title":"<code>NetworkData</code>","text":"<p>               Bases: <code>KiaraTables</code></p> <p>A flexible, graph-type agnostic wrapper class for network datasets.</p> <p>This class provides a unified interface for working with network data that can represent any type of graph structure: directed, undirected, simple, or multi-graphs. The design philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.</p> <p>Design Philosophy: - Graph Type Agnostic: Supports all graph types (directed/undirected, simple/multi)   within the same data structure without requiring type-specific conversions - Efficient Storage: Uses Apache Arrow tables for high-performance columnar storage - Flexible Querying: Provides SQL-based querying capabilities alongside programmatic access - Seamless Export: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future - Metadata Rich: Automatically computes and stores graph statistics and properties</p> <p>Internal Structure: The network data is stored as two Arrow tables: - nodes table: Contains node information with required columns '_node_id' (int) and '_label' (str) - edges table: Contains edge information with required columns '_source' (int) and '_target' (int)</p> <p>Additional computed columns (prefixed with '_') provide graph statistics for different interpretations: - Degree counts for directed/undirected graphs - Multi-edge counts and indices - Centrality measures</p> <p>Graph Type Support: - Simple Graphs: Single edges between node pairs - Multi-graphs: Multiple edges between the same node pairs - Directed Graphs: One-way edges with source \u2192 target semantics - Undirected Graphs: Bidirectional edges - Mixed Types: The same data can be interpreted as different graph types</p> <p>Note: Column names prefixed with '_' have internal meaning and are automatically computed. Original attributes from source data are stored without the prefix.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NetworkData(KiaraTables):\n    \"\"\"A flexible, graph-type agnostic wrapper class for network datasets.\n\n    This class provides a unified interface for working with network data that can represent\n    any type of graph structure: directed, undirected, simple, or multi-graphs. The design\n    philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.\n\n    **Design Philosophy:**\n    - **Graph Type Agnostic**: Supports all graph types (directed/undirected, simple/multi)\n      within the same data structure without requiring type-specific conversions\n    - **Efficient Storage**: Uses Apache Arrow tables for high-performance columnar storage\n    - **Flexible Querying**: Provides SQL-based querying capabilities alongside programmatic access\n    - **Seamless Export**: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future\n    - **Metadata Rich**: Automatically computes and stores graph statistics and properties\n\n    **Internal Structure:**\n    The network data is stored as two Arrow tables:\n    - **nodes table**: Contains node information with required columns '_node_id' (int) and '_label' (str)\n    - **edges table**: Contains edge information with required columns '_source' (int) and '_target' (int)\n\n    Additional computed columns (prefixed with '_') provide graph statistics for different interpretations:\n    - Degree counts for directed/undirected graphs\n    - Multi-edge counts and indices\n    - Centrality measures\n\n    **Graph Type Support:**\n    - **Simple Graphs**: Single edges between node pairs\n    - **Multi-graphs**: Multiple edges between the same node pairs\n    - **Directed Graphs**: One-way edges with source \u2192 target semantics\n    - **Undirected Graphs**: Bidirectional edges\n    - **Mixed Types**: The same data can be interpreted as different graph types\n\n    **Note:** Column names prefixed with '_' have internal meaning and are automatically\n    computed. Original attributes from source data are stored without the prefix.\n    \"\"\"\n\n    _kiara_model_id: ClassVar = \"instance.network_data\"\n\n    @classmethod\n    def create_augmented(\n        cls,\n        network_data: \"NetworkData\",\n        additional_edges_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n        additional_nodes_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n        nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n        edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a new NetworkData instance with additional columns.\n\n        This method creates a new NetworkData instance by adding extra columns to an existing\n        instance without recomputing the automatically generated internal columns (those\n        prefixed with '_'). This is useful for adding derived attributes or analysis results.\n\n        Args:\n            network_data: The source NetworkData instance to augment\n            additional_edges_columns: Dictionary mapping column names to PyArrow Arrays\n                for new edge attributes\n            additional_nodes_columns: Dictionary mapping column names to PyArrow Arrays\n                for new node attributes\n            nodes_column_metadata: Additional metadata to attach to nodes table columns\n            edges_column_metadata: Additional metadata to attach to edges table columns\n\n        Returns:\n            NetworkData: A new NetworkData instance with the additional columns\n\n        Example:\n            ```python\n            import pyarrow as pa\n\n            # Add a weight column to edges\n            weights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\n            augmented = NetworkData.create_augmented(\n                network_data,\n                additional_edges_columns={\"weight\": weights}\n            )\n            ```\n        \"\"\"\n\n        nodes_table = network_data.nodes.arrow_table\n        edges_table = network_data.edges.arrow_table\n\n        # nodes_table = pa.Table.from_arrays(orig_nodes_table.columns, schema=orig_nodes_table.schema)\n        # edges_table = pa.Table.from_arrays(orig_edges_table.columns, schema=orig_edges_table.schema)\n\n        if additional_edges_columns is not None:\n            for col_name, col_data in additional_edges_columns.items():\n                edges_table = edges_table.append_column(col_name, col_data)\n\n        if additional_nodes_columns is not None:\n            for col_name, col_data in additional_nodes_columns.items():\n                nodes_table = nodes_table.append_column(col_name, col_data)\n\n        new_network_data = NetworkData.create_network_data(\n            nodes_table=nodes_table,\n            edges_table=edges_table,\n            augment_tables=False,\n            nodes_column_metadata=nodes_column_metadata,\n            edges_column_metadata=edges_column_metadata,\n        )\n\n        return new_network_data\n\n    @classmethod\n    def create_network_data(\n        cls,\n        nodes_table: \"pa.Table\",\n        edges_table: \"pa.Table\",\n        augment_tables: bool = True,\n        nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n        edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a NetworkData instance from PyArrow tables.\n\n        This is the primary factory method for creating NetworkData instances from raw tabular data.\n        It supports all graph types and automatically computes necessary metadata for efficient\n        graph operations.\n\n        **Required Table Structure:**\n\n        Nodes table must contain:\n        - '_node_id' (int): Unique integer identifier for each node\n        - '_label' (str): Human-readable label for the node\n\n        Edges table must contain:\n        - '_source' (int): Source node ID (must exist in nodes table)\n        - '_target' (int): Target node ID (must exist in nodes table)\n\n        **Automatic Augmentation:**\n        When `augment_tables=True` (default), the method automatically adds computed columns:\n\n        For edges:\n        - '_edge_id': Unique edge identifier\n        - '_count_dup_directed': Count of parallel edges (directed interpretation)\n        - '_idx_dup_directed': Index within parallel edge group (directed)\n        - '_count_dup_undirected': Count of parallel edges (undirected interpretation)\n        - '_idx_dup_undirected': Index within parallel edge group (undirected)\n\n        For nodes:\n        - '_count_edges': Total edge count (simple graph interpretation)\n        - '_count_edges_multi': Total edge count (multi-graph interpretation)\n        - '_in_edges': Incoming edge count (directed, simple)\n        - '_out_edges': Outgoing edge count (directed, simple)\n        - '_in_edges_multi': Incoming edge count (directed, multi)\n        - '_out_edges_multi': Outgoing edge count (directed, multi)\n        - '_degree_centrality': Normalized degree centrality\n        - '_degree_centrality_multi': Normalized degree centrality (multi-graph)\n\n        Args:\n            nodes_table: PyArrow table containing node data\n            edges_table: PyArrow table containing edge data\n            augment_tables: Whether to compute and add internal metadata columns.\n                Set to False only if you know the metadata is already present and correct.\n            nodes_column_metadata: Additional metadata to attach to nodes table columns.\n                Format: {column_name: {property_name: property_value}}\n            edges_column_metadata: Additional metadata to attach to edges table columns.\n                Format: {column_name: {property_name: property_value}}\n\n        Returns:\n            NetworkData: A new NetworkData instance\n\n        Raises:\n            KiaraException: If required columns are missing or contain null values\n\n        \"\"\"\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_DEGREE_COLUMN_METADATA,\n            NODE_DEGREE_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        if augment_tables:\n            edges_table = augment_edges_table_with_id_and_weights(edges_table)\n            nodes_table = augment_nodes_table_with_connection_counts(\n                nodes_table, edges_table\n            )\n            nodes_table, edges_table = augment_tables_with_component_ids(\n                nodes_table=nodes_table, edges_table=edges_table\n            )\n\n        if edges_table.column(SOURCE_COLUMN_NAME).null_count &gt; 0:\n            raise KiaraException(\n                msg=\"Can't assemble network data.\",\n                details=\"Source column in edges table contains null values.\",\n            )\n        if edges_table.column(TARGET_COLUMN_NAME).null_count &gt; 0:\n            raise KiaraException(\n                msg=\"Can't assemble network data.\",\n                details=\"Target column in edges table contains null values.\",\n            )\n\n        network_data: NetworkData = cls.create_tables(\n            {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n        )\n\n        # set default column metadata\n        network_data.edges.set_column_metadata(\n            EDGE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            SOURCE_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_SOURCE_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            TARGET_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_TARGET_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        network_data.nodes.set_column_metadata(\n            NODE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            LABEL_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_LABEL_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_DEGREE_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_DEGREE_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        if nodes_column_metadata is not None:\n            for col_name, col_meta in nodes_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.nodes.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n        if edges_column_metadata is not None:\n            for col_name, col_meta in edges_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.edges.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n\n        return network_data\n\n    @classmethod\n    def from_filtered_nodes(\n        cls, network_data: \"NetworkData\", nodes_list: List[int]\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a new, filtered instance of this class using a source network, and a list of node ids to include.\n\n        Nodes/edges containing a node id not in the list will be removed from the resulting network data.\n\n        Arguments:\n            network_data: the source network data\n            nodes_list: the list of node ids to include in the filtered network data\n        \"\"\"\n\n        import duckdb\n        import polars as pl\n\n        node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        for column_name, metadata in network_data.nodes.column_metadata.items():\n            attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(  # type: ignore\n                ATTRIBUTE_PROPERTY_KEY, None\n            )\n            if attr_prop is None or not attr_prop.computed_attribute:\n                node_columns.append(column_name)\n\n        node_list_str = \", \".join([str(n) for n in nodes_list])\n\n        nodes_table = network_data.nodes.arrow_table  # noqa\n        nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n        nodes_result = duckdb.sql(nodes_query).pl()\n\n        edges_table = network_data.edges.arrow_table  # noqa\n        edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        for column_name, metadata in network_data.edges.column_metadata.items():\n            attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)  # type: ignore\n            if attr_prop is None or not attr_prop.computed_attribute:\n                edge_columns.append(column_name)\n\n        edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n        edges_result = duckdb.sql(edges_query).pl()\n\n        nodes_idx_colum = range(len(nodes_result))\n        old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n        repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n        nodes_result = nodes_result.with_columns(\n            pl.col(NODE_ID_COLUMN_NAME).replace_strict(repl_map, default=None)\n        )\n\n        edges_result = edges_result.with_columns(\n            pl.col(SOURCE_COLUMN_NAME).replace_strict(repl_map, default=None),\n            pl.col(TARGET_COLUMN_NAME).replace_strict(repl_map, default=None),\n        )\n\n        filtered = NetworkData.create_network_data(\n            nodes_table=nodes_result, edges_table=edges_result\n        )\n        return filtered\n\n    @classmethod\n    def create_from_networkx_graph(\n        cls,\n        graph: \"nx.Graph\",\n        label_attr_name: Union[str, None] = None,\n        ignore_node_attributes: Union[Iterable[str], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a NetworkData instance from any NetworkX graph type.\n\n        This method provides seamless conversion from NetworkX graphs to NetworkData,\n        preserving all node and edge attributes while automatically handling different\n        graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).\n\n        **Graph Type Support:**\n        - **nx.Graph**: Converted to undirected simple graph representation\n        - **nx.DiGraph**: Converted to directed simple graph representation\n        - **nx.MultiGraph**: Converted with multi-edge support (undirected)\n        - **nx.MultiDiGraph**: Converted with multi-edge support (directed)\n\n        **Attribute Handling:**\n        All NetworkX node and edge attributes are preserved as columns in the resulting\n        tables, except those starting with '_' (reserved for internal use).\n\n        Args:\n            graph: Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)\n            label_attr_name: Name of the node attribute to use as the node label.\n                If None, the node ID is converted to string and used as label.\n                Can also be an iterable of attribute names to try in order.\n            ignore_node_attributes: List of node attribute names to exclude from\n                the resulting nodes table\n\n        Returns:\n            NetworkData: A new NetworkData instance representing the graph\n\n        Raises:\n            KiaraException: If node/edge attributes contain names starting with '_'\n\n        Note:\n            Node IDs in the original NetworkX graph are mapped to sequential integers\n            starting from 0 in the NetworkData representation. The original node IDs\n            are preserved as the '_label' if no label_attr_name is specified.\n        \"\"\"\n\n        # TODO: should we also index nodes/edges attributes?\n\n        nodes_table, node_id_map = extract_networkx_nodes_as_table(\n            graph=graph,\n            label_attr_name=label_attr_name,\n            ignore_attributes=ignore_node_attributes,\n        )\n\n        edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes_table, edges_table=edges_table\n        )\n\n        return network_data\n\n    @property\n    def edges(self) -&gt; \"KiaraTable\":\n        \"\"\"Access the edges table containing all edge data and computed statistics.\n\n        The edges table contains both original edge attributes and computed columns:\n        - '_edge_id': Unique edge identifier\n        - '_source', '_target': Node IDs for edge endpoints\n        - '_count_dup_*': Parallel edge counts for different graph interpretations\n        - '_idx_dup_*': Indices within parallel edge groups\n        - Original edge attributes (without '_' prefix)\n\n        Returns:\n            KiaraTable: The edges table with full schema and data access methods\n        \"\"\"\n        return self.tables[EDGES_TABLE_NAME]\n\n    @property\n    def nodes(self) -&gt; \"KiaraTable\":\n        \"\"\"Access the nodes table containing all node data and computed statistics.\n\n        The nodes table contains both original node attributes and computed columns:\n        - '_node_id': Unique node identifier (sequential integers from 0)\n        - '_label': Human-readable node label\n        - '_count_edges*': Edge counts for different graph interpretations\n        - '_in_edges*', '_out_edges*': Directional edge counts\n        - '_degree_centrality*': Normalized degree centrality measures\n        - Original node attributes (without '_' prefix)\n\n        Returns:\n            KiaraTable: The nodes table with full schema and data access methods\n        \"\"\"\n        return self.tables[NODES_TABLE_NAME]\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Get the total number of nodes in the network.\n\n        Returns:\n            int: Number of nodes in the network\n        \"\"\"\n        return self.nodes.num_rows  # type: ignore\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Get the total number of edges in the network.\n\n        Note: This returns the total number of edge records, which includes\n        all parallel edges in multi-graph interpretations.\n\n        Returns:\n            int: Total number of edges (including parallel edges)\n        \"\"\"\n        return self.edges.num_rows  # type: ignore\n\n    def query_edges(\n        self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n        \"\"\"Execute SQL queries on the edges table for flexible data analysis.\n\n        This method provides direct SQL access to the edges table, enabling complex\n        queries and aggregations. All computed edge columns are available for querying.\n\n        **Available Columns:**\n        - '_edge_id': Unique edge identifier\n        - '_source', '_target': Node IDs for edge endpoints\n        - '_count_dup_directed': Number of parallel edges (directed interpretation)\n        - '_idx_dup_directed': Index within parallel edge group (directed)\n        - '_count_dup_undirected': Number of parallel edges (undirected interpretation)\n        - '_idx_dup_undirected': Index within parallel edge group (undirected)\n        - Original edge attributes (names without '_' prefix)\n\n        Args:\n            sql_query: SQL query string. Use 'edges' as the table name in your query.\n            relation_name: Alternative table name to use in the query (default: 'edges').\n                If specified, all occurrences of this name in the query will be replaced\n                with 'edges'.\n\n        Returns:\n            pa.Table: Query results as a PyArrow table\n\n        Example:\n            ```python\n            # Find edges with high multiplicity\n            parallel_edges = network_data.query_edges(\n                \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n            )\n\n            # Get edge statistics\n            stats = network_data.query_edges(\n                \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n            )\n            ```\n        \"\"\"\n        import duckdb\n\n        con = duckdb.connect()\n        edges = self.edges.arrow_table  # noqa: F841\n        if relation_name != EDGES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def query_nodes(\n        self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n        \"\"\"Execute SQL queries on the nodes table for flexible data analysis.\n\n        This method provides direct SQL access to the nodes table, enabling complex\n        queries and aggregations. All computed node statistics are available for querying.\n\n        **Available Columns:**\n        - '_node_id': Unique node identifier\n        - '_label': Human-readable node label\n        - '_count_edges': Total edge count (simple graph interpretation)\n        - '_count_edges_multi': Total edge count (multi-graph interpretation)\n        - '_in_edges': Incoming edge count (directed, simple)\n        - '_out_edges': Outgoing edge count (directed, simple)\n        - '_in_edges_multi': Incoming edge count (directed, multi)\n        - '_out_edges_multi': Outgoing edge count (directed, multi)\n        - '_degree_centrality': Normalized degree centrality (simple)\n        - '_degree_centrality_multi': Normalized degree centrality (multi)\n        - Original node attributes (names without '_' prefix)\n\n        Args:\n            sql_query: SQL query string. Use 'nodes' as the table name in your query.\n            relation_name: Alternative table name to use in the query (default: 'nodes').\n                If specified, all occurrences of this name in the query will be replaced\n                with 'nodes'.\n\n        Returns:\n            pa.Table: Query results as a PyArrow table\n\n        Example:\n            ```python\n            # Find high-degree nodes\n            hubs = network_data.query_nodes(\n                \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n            )\n\n            # Get centrality statistics\n            centrality_stats = network_data.query_nodes(\n                \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n            )\n            ```\n        \"\"\"\n        import duckdb\n\n        con = duckdb.connect()\n        nodes = self.nodes.arrow_table  # noqa\n        if relation_name != NODES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def _calculate_node_attributes(\n        self, incl_node_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n        \"\"\"Calculate the node attributes that should be included in the output.\"\"\"\n\n        if incl_node_attributes is False:\n            node_attr_names: List[str] = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        else:\n            all_node_attr_names: List[str] = self.nodes.column_names  # type: ignore\n            if incl_node_attributes is True:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                node_attr_names.extend(\n                    (x for x in all_node_attr_names if x != NODE_ID_COLUMN_NAME)\n                )  # type: ignore\n            elif isinstance(incl_node_attributes, str):\n                if incl_node_attributes not in all_node_attr_names:\n                    raise KiaraException(\n                        f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                    )\n                node_attr_names = [NODE_ID_COLUMN_NAME, incl_node_attributes]\n            else:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                for attr_name in incl_node_attributes:\n                    if attr_name not in all_node_attr_names:\n                        raise KiaraException(\n                            f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                        )\n                    node_attr_names.append(attr_name)  # type: ignore\n\n        return node_attr_names\n\n    def _calculate_edge_attributes(\n        self, incl_edge_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n        \"\"\"Calculate the edge attributes that should be included in the output.\"\"\"\n\n        if incl_edge_attributes is False:\n            edge_attr_names: List[str] = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        else:\n            all_edge_attr_names: List[str] = self.edges.column_names  # type: ignore\n            if incl_edge_attributes is True:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                edge_attr_names.extend(\n                    (\n                        x\n                        for x in all_edge_attr_names\n                        if x not in (SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME)\n                    )\n                )  # type: ignore\n            elif isinstance(incl_edge_attributes, str):\n                if incl_edge_attributes not in all_edge_attr_names:\n                    raise KiaraException(\n                        f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                    )\n                edge_attr_names = [\n                    SOURCE_COLUMN_NAME,\n                    TARGET_COLUMN_NAME,\n                    incl_edge_attributes,\n                ]\n            else:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                for attr_name in incl_edge_attributes:\n                    if attr_name not in all_edge_attr_names:\n                        raise KiaraException(\n                            f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                        )\n                    edge_attr_names.append(attr_name)  # type: ignore\n\n        return edge_attr_names\n\n    def retrieve_graph_data(\n        self,\n        nodes_callback: Union[NodesCallback, None] = None,\n        edges_callback: Union[EdgesCallback, None] = None,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ):\n        \"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n        First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n        The nodes_callback will be called with the following arguments:\n            - node_id: the id of the node (int)\n            - if False: nothing else\n            - if True: all node attributes, in the order they are defined in the table schema\n            - if str: the value of the specified node attribute\n            - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n        The edges_callback will be called with the following aruments:\n            - source_id: the id of the source node (int)\n            - target_id: the id of the target node (int)\n            - if False: nothing else\n            - if True: all edge attributes, in the order they are defined in the table schema\n            - if str: the value of the specified edge attribute\n            - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n        \"\"\"\n\n        if nodes_callback is not None:\n            node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n            nodes_df = self.nodes.to_polars_dataframe()\n            for row in nodes_df.select(*node_attr_names).rows(named=True):\n                nodes_callback(**row)  # type: ignore\n\n        if edges_callback is not None:\n            edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n            edges_df = self.edges.to_polars_dataframe()\n            for row in edges_df.select(*edge_attr_names).rows(named=True):\n                if (\n                    omit_self_loops\n                    and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n                ):\n                    continue\n                edges_callback(**row)  # type: ignore\n\n    def as_networkx_graph(\n        self,\n        graph_type: Type[NETWORKX_GRAPH_TYPE],\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ) -&gt; NETWORKX_GRAPH_TYPE:\n        \"\"\"Export the network data as a NetworkX graph object.\n\n        This method converts the NetworkData to any NetworkX graph type, providing\n        flexibility to work with the data using NetworkX's extensive algorithm library.\n        The conversion preserves node and edge attributes as specified.\n\n        **Supported Graph Types:**\n        - **nx.Graph**: Undirected simple graph (parallel edges are merged)\n        - **nx.DiGraph**: Directed simple graph (parallel edges are merged)\n        - **nx.MultiGraph**: Undirected multigraph (parallel edges preserved)\n        - **nx.MultiDiGraph**: Directed multigraph (parallel edges preserved)\n\n        **Attribute Handling:**\n        Node and edge attributes can be selectively included in the exported graph.\n        Internal columns (prefixed with '_') are available but typically excluded\n        from exports to maintain clean NetworkX compatibility.\n\n        Args:\n            graph_type: NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)\n            incl_node_attributes: Controls which node attributes to include:\n                - False: No attributes (only node IDs)\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            incl_edge_attributes: Controls which edge attributes to include:\n                - False: No attributes\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            omit_self_loops: If True, edges where source equals target are excluded\n\n        Returns:\n            NETWORKX_GRAPH_TYPE: NetworkX graph instance of the specified type\n\n        Note:\n            When exporting to simple graph types (Graph, DiGraph), parallel edges\n            are automatically merged. Use MultiGraph or MultiDiGraph to preserve\n            all edge instances.\n        \"\"\"\n\n        graph: NETWORKX_GRAPH_TYPE = graph_type()\n\n        def add_node(_node_id: int, **attrs):\n            graph.add_node(_node_id, **attrs)\n\n        def add_edge(_source: int, _target: int, **attrs):\n            graph.add_edge(_source, _target, **attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        return graph\n\n    def as_rustworkx_graph(\n        self,\n        graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n        multigraph: bool = False,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n        attach_node_id_map: bool = False,\n    ) -&gt; RUSTWORKX_GRAPH_TYPE:\n        \"\"\"Export the network data as a RustWorkX graph object.\n\n        RustWorkX provides high-performance graph algorithms implemented in Rust with\n        Python bindings. This method converts NetworkData to RustWorkX format while\n        handling the differences in node ID management between the two systems.\n\n        **Supported Graph Types:**\n        - **rx.PyGraph**: Undirected graph (with optional multigraph support)\n        - **rx.PyDiGraph**: Directed graph (with optional multigraph support)\n\n        **Node ID Mapping:**\n        RustWorkX uses sequential integer node IDs starting from 0, which may differ\n        from the original NetworkData node IDs. The original '_node_id' values are\n        preserved as node attributes, and an optional mapping can be attached to\n        the graph for reference.\n\n        **Performance Benefits:**\n        RustWorkX graphs offer significant performance advantages for:\n        - Large-scale graph algorithms\n        - Parallel processing\n        - Memory-efficient operations\n        - High-performance centrality calculations\n\n        Args:\n            graph_type: RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)\n            multigraph: If True, parallel edges are preserved; if False, they are merged\n            incl_node_attributes: Controls which node attributes to include:\n                - False: No attributes (only node data structure)\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            incl_edge_attributes: Controls which edge attributes to include:\n                - False: No attributes\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            omit_self_loops: If True, self-loops (edges where source == target) are excluded\n            attach_node_id_map: If True, adds a 'node_id_map' attribute to the graph\n                containing the mapping from RustWorkX node IDs to original NetworkData node IDs\n\n        Returns:\n            RUSTWORKX_GRAPH_TYPE: RustWorkX graph instance of the specified type\n\n        Note:\n            The original NetworkData '_node_id' values are always included in the\n            node data dictionary, regardless of the incl_node_attributes setting.\n        \"\"\"\n\n        from bidict import bidict\n\n        graph = graph_type(multigraph=multigraph)\n\n        # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n        # include node attributes)\n\n        self._calculate_node_attributes(incl_node_attributes)[1:]\n        self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n        # we can use a 'global' dict here because we know the nodes are processed before the edges\n        node_map: bidict = bidict()\n\n        def add_node(_node_id: int, **attrs):\n            data = {NODE_ID_COLUMN_NAME: _node_id}\n            data.update(attrs)\n\n            graph_node_id = graph.add_node(data)\n\n            node_map[graph_node_id] = _node_id\n            # if not _node_id == graph_node_id:\n            #     raise Exception(\"Internal error: node ids don't match\")\n\n        def add_edge(_source: int, _target: int, **attrs):\n            source = node_map[_source]\n            target = node_map[_target]\n            if not attrs:\n                graph.add_edge(source, target, None)\n            else:\n                graph.add_edge(source, target, attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        if attach_node_id_map:\n            graph.attrs = {\"node_id_map\": node_map}  # type: ignore\n\n        return graph\n\n    @property\n    def component_ids(self) -&gt; Set[int]:\n        import duckdb\n\n        nodes_table = self.nodes.arrow_table  # noqa\n        query = f\"\"\"\n        SELECT DISTINCT {COMPONENT_ID_COLUMN_NAME} FROM nodes_table\n        \"\"\"\n\n        result: Set[int] = set([x[0] for x in duckdb.sql(query).fetchall()])\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.edges","title":"<code>edges: KiaraTable</code>  <code>property</code>","text":"<p>Access the edges table containing all edge data and computed statistics.</p> <p>The edges table contains both original edge attributes and computed columns: - 'edge_id': Unique edge identifier - '_source', '_target': Node IDs for edge endpoints - '_count_dup': Parallel edge counts for different graph interpretations - 'idx_dup': Indices within parallel edge groups - Original edge attributes (without '_' prefix)</p> <p>Returns:</p> Name Type Description <code>KiaraTable</code> <code>KiaraTable</code> <p>The edges table with full schema and data access methods</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.nodes","title":"<code>nodes: KiaraTable</code>  <code>property</code>","text":"<p>Access the nodes table containing all node data and computed statistics.</p> <p>The nodes table contains both original node attributes and computed columns: - 'node_id': Unique node identifier (sequential integers from 0) - '_label': Human-readable node label - '_count_edges': Edge counts for different graph interpretations - '_in_edges', '_out_edges': Directional edge counts - '_degree_centrality': Normalized degree centrality measures - Original node attributes (without '' prefix)</p> <p>Returns:</p> Name Type Description <code>KiaraTable</code> <code>KiaraTable</code> <p>The nodes table with full schema and data access methods</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.num_nodes","title":"<code>num_nodes: int</code>  <code>property</code>","text":"<p>Get the total number of nodes in the network.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of nodes in the network</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.num_edges","title":"<code>num_edges: int</code>  <code>property</code>","text":"<p>Get the total number of edges in the network.</p> <p>Note: This returns the total number of edge records, which includes all parallel edges in multi-graph interpretations.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of edges (including parallel edges)</p>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.component_ids","title":"<code>component_ids: Set[int]</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.create_augmented","title":"<code>create_augmented(network_data: NetworkData, additional_edges_columns: Union[None, Dict[str, pa.Array]] = None, additional_nodes_columns: Union[None, Dict[str, pa.Array]] = None, nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None, edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a new NetworkData instance with additional columns.</p> <p>This method creates a new NetworkData instance by adding extra columns to an existing instance without recomputing the automatically generated internal columns (those prefixed with '_'). This is useful for adding derived attributes or analysis results.</p> <p>Parameters:</p> Name Type Description Default <code>network_data</code> <code>NetworkData</code> <p>The source NetworkData instance to augment</p> required <code>additional_edges_columns</code> <code>Union[None, Dict[str, Array]]</code> <p>Dictionary mapping column names to PyArrow Arrays for new edge attributes</p> <code>None</code> <code>additional_nodes_columns</code> <code>Union[None, Dict[str, Array]]</code> <p>Dictionary mapping column names to PyArrow Arrays for new node attributes</p> <code>None</code> <code>nodes_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to nodes table columns</p> <code>None</code> <code>edges_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to edges table columns</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance with the additional columns</p> Example <pre><code>import pyarrow as pa\n\n# Add a weight column to edges\nweights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\naugmented = NetworkData.create_augmented(\n    network_data,\n    additional_edges_columns={\"weight\": weights}\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_augmented(\n    cls,\n    network_data: \"NetworkData\",\n    additional_edges_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n    additional_nodes_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n    nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a new NetworkData instance with additional columns.\n\n    This method creates a new NetworkData instance by adding extra columns to an existing\n    instance without recomputing the automatically generated internal columns (those\n    prefixed with '_'). This is useful for adding derived attributes or analysis results.\n\n    Args:\n        network_data: The source NetworkData instance to augment\n        additional_edges_columns: Dictionary mapping column names to PyArrow Arrays\n            for new edge attributes\n        additional_nodes_columns: Dictionary mapping column names to PyArrow Arrays\n            for new node attributes\n        nodes_column_metadata: Additional metadata to attach to nodes table columns\n        edges_column_metadata: Additional metadata to attach to edges table columns\n\n    Returns:\n        NetworkData: A new NetworkData instance with the additional columns\n\n    Example:\n        ```python\n        import pyarrow as pa\n\n        # Add a weight column to edges\n        weights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\n        augmented = NetworkData.create_augmented(\n            network_data,\n            additional_edges_columns={\"weight\": weights}\n        )\n        ```\n    \"\"\"\n\n    nodes_table = network_data.nodes.arrow_table\n    edges_table = network_data.edges.arrow_table\n\n    # nodes_table = pa.Table.from_arrays(orig_nodes_table.columns, schema=orig_nodes_table.schema)\n    # edges_table = pa.Table.from_arrays(orig_edges_table.columns, schema=orig_edges_table.schema)\n\n    if additional_edges_columns is not None:\n        for col_name, col_data in additional_edges_columns.items():\n            edges_table = edges_table.append_column(col_name, col_data)\n\n    if additional_nodes_columns is not None:\n        for col_name, col_data in additional_nodes_columns.items():\n            nodes_table = nodes_table.append_column(col_name, col_data)\n\n    new_network_data = NetworkData.create_network_data(\n        nodes_table=nodes_table,\n        edges_table=edges_table,\n        augment_tables=False,\n        nodes_column_metadata=nodes_column_metadata,\n        edges_column_metadata=edges_column_metadata,\n    )\n\n    return new_network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.create_network_data","title":"<code>create_network_data(nodes_table: pa.Table, edges_table: pa.Table, augment_tables: bool = True, nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None, edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a NetworkData instance from PyArrow tables.</p> <p>This is the primary factory method for creating NetworkData instances from raw tabular data. It supports all graph types and automatically computes necessary metadata for efficient graph operations.</p> <p>Required Table Structure:</p> <p>Nodes table must contain: - '_node_id' (int): Unique integer identifier for each node - '_label' (str): Human-readable label for the node</p> <p>Edges table must contain: - '_source' (int): Source node ID (must exist in nodes table) - '_target' (int): Target node ID (must exist in nodes table)</p> <p>Automatic Augmentation: When <code>augment_tables=True</code> (default), the method automatically adds computed columns:</p> <p>For edges: - '_edge_id': Unique edge identifier - '_count_dup_directed': Count of parallel edges (directed interpretation) - '_idx_dup_directed': Index within parallel edge group (directed) - '_count_dup_undirected': Count of parallel edges (undirected interpretation) - '_idx_dup_undirected': Index within parallel edge group (undirected)</p> <p>For nodes: - '_count_edges': Total edge count (simple graph interpretation) - '_count_edges_multi': Total edge count (multi-graph interpretation) - '_in_edges': Incoming edge count (directed, simple) - '_out_edges': Outgoing edge count (directed, simple) - '_in_edges_multi': Incoming edge count (directed, multi) - '_out_edges_multi': Outgoing edge count (directed, multi) - '_degree_centrality': Normalized degree centrality - '_degree_centrality_multi': Normalized degree centrality (multi-graph)</p> <p>Parameters:</p> Name Type Description Default <code>nodes_table</code> <code>Table</code> <p>PyArrow table containing node data</p> required <code>edges_table</code> <code>Table</code> <p>PyArrow table containing edge data</p> required <code>augment_tables</code> <code>bool</code> <p>Whether to compute and add internal metadata columns. Set to False only if you know the metadata is already present and correct.</p> <code>True</code> <code>nodes_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to nodes table columns. Format: {column_name: {property_name: property_value}}</p> <code>None</code> <code>edges_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to edges table columns. Format: {column_name: {property_name: property_value}}</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance</p> <p>Raises:</p> Type Description <code>KiaraException</code> <p>If required columns are missing or contain null values</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_network_data(\n    cls,\n    nodes_table: \"pa.Table\",\n    edges_table: \"pa.Table\",\n    augment_tables: bool = True,\n    nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a NetworkData instance from PyArrow tables.\n\n    This is the primary factory method for creating NetworkData instances from raw tabular data.\n    It supports all graph types and automatically computes necessary metadata for efficient\n    graph operations.\n\n    **Required Table Structure:**\n\n    Nodes table must contain:\n    - '_node_id' (int): Unique integer identifier for each node\n    - '_label' (str): Human-readable label for the node\n\n    Edges table must contain:\n    - '_source' (int): Source node ID (must exist in nodes table)\n    - '_target' (int): Target node ID (must exist in nodes table)\n\n    **Automatic Augmentation:**\n    When `augment_tables=True` (default), the method automatically adds computed columns:\n\n    For edges:\n    - '_edge_id': Unique edge identifier\n    - '_count_dup_directed': Count of parallel edges (directed interpretation)\n    - '_idx_dup_directed': Index within parallel edge group (directed)\n    - '_count_dup_undirected': Count of parallel edges (undirected interpretation)\n    - '_idx_dup_undirected': Index within parallel edge group (undirected)\n\n    For nodes:\n    - '_count_edges': Total edge count (simple graph interpretation)\n    - '_count_edges_multi': Total edge count (multi-graph interpretation)\n    - '_in_edges': Incoming edge count (directed, simple)\n    - '_out_edges': Outgoing edge count (directed, simple)\n    - '_in_edges_multi': Incoming edge count (directed, multi)\n    - '_out_edges_multi': Outgoing edge count (directed, multi)\n    - '_degree_centrality': Normalized degree centrality\n    - '_degree_centrality_multi': Normalized degree centrality (multi-graph)\n\n    Args:\n        nodes_table: PyArrow table containing node data\n        edges_table: PyArrow table containing edge data\n        augment_tables: Whether to compute and add internal metadata columns.\n            Set to False only if you know the metadata is already present and correct.\n        nodes_column_metadata: Additional metadata to attach to nodes table columns.\n            Format: {column_name: {property_name: property_value}}\n        edges_column_metadata: Additional metadata to attach to edges table columns.\n            Format: {column_name: {property_name: property_value}}\n\n    Returns:\n        NetworkData: A new NetworkData instance\n\n    Raises:\n        KiaraException: If required columns are missing or contain null values\n\n    \"\"\"\n\n    from kiara_plugin.network_analysis.models.metadata import (\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_ID_COLUMN_METADATA,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_SOURCE_COLUMN_METADATA,\n        EDGE_TARGET_COLUMN_METADATA,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        NODE_DEGREE_COLUMN_METADATA,\n        NODE_DEGREE_MULTI_COLUMN_METADATA,\n        NODE_ID_COLUMN_METADATA,\n        NODE_LABEL_COLUMN_METADATA,\n    )\n\n    if augment_tables:\n        edges_table = augment_edges_table_with_id_and_weights(edges_table)\n        nodes_table = augment_nodes_table_with_connection_counts(\n            nodes_table, edges_table\n        )\n        nodes_table, edges_table = augment_tables_with_component_ids(\n            nodes_table=nodes_table, edges_table=edges_table\n        )\n\n    if edges_table.column(SOURCE_COLUMN_NAME).null_count &gt; 0:\n        raise KiaraException(\n            msg=\"Can't assemble network data.\",\n            details=\"Source column in edges table contains null values.\",\n        )\n    if edges_table.column(TARGET_COLUMN_NAME).null_count &gt; 0:\n        raise KiaraException(\n            msg=\"Can't assemble network data.\",\n            details=\"Target column in edges table contains null values.\",\n        )\n\n    network_data: NetworkData = cls.create_tables(\n        {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n    )\n\n    # set default column metadata\n    network_data.edges.set_column_metadata(\n        EDGE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        SOURCE_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_SOURCE_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        TARGET_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_TARGET_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    network_data.nodes.set_column_metadata(\n        NODE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        LABEL_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_LABEL_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_DEGREE_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_DEGREE_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    if nodes_column_metadata is not None:\n        for col_name, col_meta in nodes_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.nodes.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n    if edges_column_metadata is not None:\n        for col_name, col_meta in edges_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.edges.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.from_filtered_nodes","title":"<code>from_filtered_nodes(network_data: NetworkData, nodes_list: List[int]) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a new, filtered instance of this class using a source network, and a list of node ids to include.</p> <p>Nodes/edges containing a node id not in the list will be removed from the resulting network data.</p> <p>Parameters:</p> Name Type Description Default <code>network_data</code> <code>NetworkData</code> <p>the source network data</p> required <code>nodes_list</code> <code>List[int]</code> <p>the list of node ids to include in the filtered network data</p> required Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef from_filtered_nodes(\n    cls, network_data: \"NetworkData\", nodes_list: List[int]\n) -&gt; \"NetworkData\":\n    \"\"\"Create a new, filtered instance of this class using a source network, and a list of node ids to include.\n\n    Nodes/edges containing a node id not in the list will be removed from the resulting network data.\n\n    Arguments:\n        network_data: the source network data\n        nodes_list: the list of node ids to include in the filtered network data\n    \"\"\"\n\n    import duckdb\n    import polars as pl\n\n    node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n    for column_name, metadata in network_data.nodes.column_metadata.items():\n        attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(  # type: ignore\n            ATTRIBUTE_PROPERTY_KEY, None\n        )\n        if attr_prop is None or not attr_prop.computed_attribute:\n            node_columns.append(column_name)\n\n    node_list_str = \", \".join([str(n) for n in nodes_list])\n\n    nodes_table = network_data.nodes.arrow_table  # noqa\n    nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n    nodes_result = duckdb.sql(nodes_query).pl()\n\n    edges_table = network_data.edges.arrow_table  # noqa\n    edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n    for column_name, metadata in network_data.edges.column_metadata.items():\n        attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)  # type: ignore\n        if attr_prop is None or not attr_prop.computed_attribute:\n            edge_columns.append(column_name)\n\n    edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n    edges_result = duckdb.sql(edges_query).pl()\n\n    nodes_idx_colum = range(len(nodes_result))\n    old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n    repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n    nodes_result = nodes_result.with_columns(\n        pl.col(NODE_ID_COLUMN_NAME).replace_strict(repl_map, default=None)\n    )\n\n    edges_result = edges_result.with_columns(\n        pl.col(SOURCE_COLUMN_NAME).replace_strict(repl_map, default=None),\n        pl.col(TARGET_COLUMN_NAME).replace_strict(repl_map, default=None),\n    )\n\n    filtered = NetworkData.create_network_data(\n        nodes_table=nodes_result, edges_table=edges_result\n    )\n    return filtered\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.create_from_networkx_graph","title":"<code>create_from_networkx_graph(graph: nx.Graph, label_attr_name: Union[str, None] = None, ignore_node_attributes: Union[Iterable[str], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a NetworkData instance from any NetworkX graph type.</p> <p>This method provides seamless conversion from NetworkX graphs to NetworkData, preserving all node and edge attributes while automatically handling different graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).</p> <p>Graph Type Support: - nx.Graph: Converted to undirected simple graph representation - nx.DiGraph: Converted to directed simple graph representation - nx.MultiGraph: Converted with multi-edge support (undirected) - nx.MultiDiGraph: Converted with multi-edge support (directed)</p> <p>Attribute Handling: All NetworkX node and edge attributes are preserved as columns in the resulting tables, except those starting with '_' (reserved for internal use).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)</p> required <code>label_attr_name</code> <code>Union[str, None]</code> <p>Name of the node attribute to use as the node label. If None, the node ID is converted to string and used as label. Can also be an iterable of attribute names to try in order.</p> <code>None</code> <code>ignore_node_attributes</code> <code>Union[Iterable[str], None]</code> <p>List of node attribute names to exclude from the resulting nodes table</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance representing the graph</p> <p>Raises:</p> Type Description <code>KiaraException</code> <p>If node/edge attributes contain names starting with '_'</p> Note <p>Node IDs in the original NetworkX graph are mapped to sequential integers starting from 0 in the NetworkData representation. The original node IDs are preserved as the '_label' if no label_attr_name is specified.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_from_networkx_graph(\n    cls,\n    graph: \"nx.Graph\",\n    label_attr_name: Union[str, None] = None,\n    ignore_node_attributes: Union[Iterable[str], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a NetworkData instance from any NetworkX graph type.\n\n    This method provides seamless conversion from NetworkX graphs to NetworkData,\n    preserving all node and edge attributes while automatically handling different\n    graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).\n\n    **Graph Type Support:**\n    - **nx.Graph**: Converted to undirected simple graph representation\n    - **nx.DiGraph**: Converted to directed simple graph representation\n    - **nx.MultiGraph**: Converted with multi-edge support (undirected)\n    - **nx.MultiDiGraph**: Converted with multi-edge support (directed)\n\n    **Attribute Handling:**\n    All NetworkX node and edge attributes are preserved as columns in the resulting\n    tables, except those starting with '_' (reserved for internal use).\n\n    Args:\n        graph: Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)\n        label_attr_name: Name of the node attribute to use as the node label.\n            If None, the node ID is converted to string and used as label.\n            Can also be an iterable of attribute names to try in order.\n        ignore_node_attributes: List of node attribute names to exclude from\n            the resulting nodes table\n\n    Returns:\n        NetworkData: A new NetworkData instance representing the graph\n\n    Raises:\n        KiaraException: If node/edge attributes contain names starting with '_'\n\n    Note:\n        Node IDs in the original NetworkX graph are mapped to sequential integers\n        starting from 0 in the NetworkData representation. The original node IDs\n        are preserved as the '_label' if no label_attr_name is specified.\n    \"\"\"\n\n    # TODO: should we also index nodes/edges attributes?\n\n    nodes_table, node_id_map = extract_networkx_nodes_as_table(\n        graph=graph,\n        label_attr_name=label_attr_name,\n        ignore_attributes=ignore_node_attributes,\n    )\n\n    edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes_table, edges_table=edges_table\n    )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.query_edges","title":"<code>query_edges(sql_query: str, relation_name: str = EDGES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Execute SQL queries on the edges table for flexible data analysis.</p> <p>This method provides direct SQL access to the edges table, enabling complex queries and aggregations. All computed edge columns are available for querying.</p> <p>Available Columns: - 'edge_id': Unique edge identifier - '_source', '_target': Node IDs for edge endpoints - '_count_dup_directed': Number of parallel edges (directed interpretation) - '_idx_dup_directed': Index within parallel edge group (directed) - '_count_dup_undirected': Number of parallel edges (undirected interpretation) - '_idx_dup_undirected': Index within parallel edge group (undirected) - Original edge attributes (names without '' prefix)</p> <p>Parameters:</p> Name Type Description Default <code>sql_query</code> <code>str</code> <p>SQL query string. Use 'edges' as the table name in your query.</p> required <code>relation_name</code> <code>str</code> <p>Alternative table name to use in the query (default: 'edges'). If specified, all occurrences of this name in the query will be replaced with 'edges'.</p> <code>EDGES_TABLE_NAME</code> <p>Returns:</p> Type Description <code>Table</code> <p>pa.Table: Query results as a PyArrow table</p> Example <pre><code># Find edges with high multiplicity\nparallel_edges = network_data.query_edges(\n    \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n)\n\n# Get edge statistics\nstats = network_data.query_edges(\n    \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_edges(\n    self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n) -&gt; \"pa.Table\":\n    \"\"\"Execute SQL queries on the edges table for flexible data analysis.\n\n    This method provides direct SQL access to the edges table, enabling complex\n    queries and aggregations. All computed edge columns are available for querying.\n\n    **Available Columns:**\n    - '_edge_id': Unique edge identifier\n    - '_source', '_target': Node IDs for edge endpoints\n    - '_count_dup_directed': Number of parallel edges (directed interpretation)\n    - '_idx_dup_directed': Index within parallel edge group (directed)\n    - '_count_dup_undirected': Number of parallel edges (undirected interpretation)\n    - '_idx_dup_undirected': Index within parallel edge group (undirected)\n    - Original edge attributes (names without '_' prefix)\n\n    Args:\n        sql_query: SQL query string. Use 'edges' as the table name in your query.\n        relation_name: Alternative table name to use in the query (default: 'edges').\n            If specified, all occurrences of this name in the query will be replaced\n            with 'edges'.\n\n    Returns:\n        pa.Table: Query results as a PyArrow table\n\n    Example:\n        ```python\n        # Find edges with high multiplicity\n        parallel_edges = network_data.query_edges(\n            \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n        )\n\n        # Get edge statistics\n        stats = network_data.query_edges(\n            \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n        )\n        ```\n    \"\"\"\n    import duckdb\n\n    con = duckdb.connect()\n    edges = self.edges.arrow_table  # noqa: F841\n    if relation_name != EDGES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.query_nodes","title":"<code>query_nodes(sql_query: str, relation_name: str = NODES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Execute SQL queries on the nodes table for flexible data analysis.</p> <p>This method provides direct SQL access to the nodes table, enabling complex queries and aggregations. All computed node statistics are available for querying.</p> <p>Available Columns: - 'node_id': Unique node identifier - '_label': Human-readable node label - '_count_edges': Total edge count (simple graph interpretation) - '_count_edges_multi': Total edge count (multi-graph interpretation) - '_in_edges': Incoming edge count (directed, simple) - '_out_edges': Outgoing edge count (directed, simple) - '_in_edges_multi': Incoming edge count (directed, multi) - '_out_edges_multi': Outgoing edge count (directed, multi) - '_degree_centrality': Normalized degree centrality (simple) - '_degree_centrality_multi': Normalized degree centrality (multi) - Original node attributes (names without '' prefix)</p> <p>Parameters:</p> Name Type Description Default <code>sql_query</code> <code>str</code> <p>SQL query string. Use 'nodes' as the table name in your query.</p> required <code>relation_name</code> <code>str</code> <p>Alternative table name to use in the query (default: 'nodes'). If specified, all occurrences of this name in the query will be replaced with 'nodes'.</p> <code>NODES_TABLE_NAME</code> <p>Returns:</p> Type Description <code>Table</code> <p>pa.Table: Query results as a PyArrow table</p> Example <pre><code># Find high-degree nodes\nhubs = network_data.query_nodes(\n    \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n)\n\n# Get centrality statistics\ncentrality_stats = network_data.query_nodes(\n    \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_nodes(\n    self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n) -&gt; \"pa.Table\":\n    \"\"\"Execute SQL queries on the nodes table for flexible data analysis.\n\n    This method provides direct SQL access to the nodes table, enabling complex\n    queries and aggregations. All computed node statistics are available for querying.\n\n    **Available Columns:**\n    - '_node_id': Unique node identifier\n    - '_label': Human-readable node label\n    - '_count_edges': Total edge count (simple graph interpretation)\n    - '_count_edges_multi': Total edge count (multi-graph interpretation)\n    - '_in_edges': Incoming edge count (directed, simple)\n    - '_out_edges': Outgoing edge count (directed, simple)\n    - '_in_edges_multi': Incoming edge count (directed, multi)\n    - '_out_edges_multi': Outgoing edge count (directed, multi)\n    - '_degree_centrality': Normalized degree centrality (simple)\n    - '_degree_centrality_multi': Normalized degree centrality (multi)\n    - Original node attributes (names without '_' prefix)\n\n    Args:\n        sql_query: SQL query string. Use 'nodes' as the table name in your query.\n        relation_name: Alternative table name to use in the query (default: 'nodes').\n            If specified, all occurrences of this name in the query will be replaced\n            with 'nodes'.\n\n    Returns:\n        pa.Table: Query results as a PyArrow table\n\n    Example:\n        ```python\n        # Find high-degree nodes\n        hubs = network_data.query_nodes(\n            \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n        )\n\n        # Get centrality statistics\n        centrality_stats = network_data.query_nodes(\n            \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n        )\n        ```\n    \"\"\"\n    import duckdb\n\n    con = duckdb.connect()\n    nodes = self.nodes.arrow_table  # noqa\n    if relation_name != NODES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.retrieve_graph_data","title":"<code>retrieve_graph_data(nodes_callback: Union[NodesCallback, None] = None, edges_callback: Union[EdgesCallback, None] = None, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False)</code>","text":"<p>Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.</p> <p>First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.</p> The nodes_callback will be called with the following arguments <ul> <li>node_id: the id of the node (int)</li> <li>if False: nothing else</li> <li>if True: all node attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified node attribute</li> <li>if Iterable[str]: the values of the specified node attributes, in the order they are specified</li> </ul> The edges_callback will be called with the following aruments <ul> <li>source_id: the id of the source node (int)</li> <li>target_id: the id of the target node (int)</li> <li>if False: nothing else</li> <li>if True: all edge attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified edge attribute</li> <li>if Iterable[str]: the values of the specified edge attributes, in the order they are specified</li> </ul> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def retrieve_graph_data(\n    self,\n    nodes_callback: Union[NodesCallback, None] = None,\n    edges_callback: Union[EdgesCallback, None] = None,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n):\n    \"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n    First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n    The nodes_callback will be called with the following arguments:\n        - node_id: the id of the node (int)\n        - if False: nothing else\n        - if True: all node attributes, in the order they are defined in the table schema\n        - if str: the value of the specified node attribute\n        - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n    The edges_callback will be called with the following aruments:\n        - source_id: the id of the source node (int)\n        - target_id: the id of the target node (int)\n        - if False: nothing else\n        - if True: all edge attributes, in the order they are defined in the table schema\n        - if str: the value of the specified edge attribute\n        - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n    \"\"\"\n\n    if nodes_callback is not None:\n        node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n        nodes_df = self.nodes.to_polars_dataframe()\n        for row in nodes_df.select(*node_attr_names).rows(named=True):\n            nodes_callback(**row)  # type: ignore\n\n    if edges_callback is not None:\n        edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n        edges_df = self.edges.to_polars_dataframe()\n        for row in edges_df.select(*edge_attr_names).rows(named=True):\n            if (\n                omit_self_loops\n                and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n            ):\n                continue\n            edges_callback(**row)  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.as_networkx_graph","title":"<code>as_networkx_graph(graph_type: Type[NETWORKX_GRAPH_TYPE], incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False) -&gt; NETWORKX_GRAPH_TYPE</code>","text":"<p>Export the network data as a NetworkX graph object.</p> <p>This method converts the NetworkData to any NetworkX graph type, providing flexibility to work with the data using NetworkX's extensive algorithm library. The conversion preserves node and edge attributes as specified.</p> <p>Supported Graph Types: - nx.Graph: Undirected simple graph (parallel edges are merged) - nx.DiGraph: Directed simple graph (parallel edges are merged) - nx.MultiGraph: Undirected multigraph (parallel edges preserved) - nx.MultiDiGraph: Directed multigraph (parallel edges preserved)</p> <p>Attribute Handling: Node and edge attributes can be selectively included in the exported graph. Internal columns (prefixed with '_') are available but typically excluded from exports to maintain clean NetworkX compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[NETWORKX_GRAPH_TYPE]</code> <p>NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)</p> required <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which node attributes to include: - False: No attributes (only node IDs) - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which edge attributes to include: - False: No attributes - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>If True, edges where source equals target are excluded</p> <code>False</code> <p>Returns:</p> Name Type Description <code>NETWORKX_GRAPH_TYPE</code> <code>NETWORKX_GRAPH_TYPE</code> <p>NetworkX graph instance of the specified type</p> Note <p>When exporting to simple graph types (Graph, DiGraph), parallel edges are automatically merged. Use MultiGraph or MultiDiGraph to preserve all edge instances.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_networkx_graph(\n    self,\n    graph_type: Type[NETWORKX_GRAPH_TYPE],\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n) -&gt; NETWORKX_GRAPH_TYPE:\n    \"\"\"Export the network data as a NetworkX graph object.\n\n    This method converts the NetworkData to any NetworkX graph type, providing\n    flexibility to work with the data using NetworkX's extensive algorithm library.\n    The conversion preserves node and edge attributes as specified.\n\n    **Supported Graph Types:**\n    - **nx.Graph**: Undirected simple graph (parallel edges are merged)\n    - **nx.DiGraph**: Directed simple graph (parallel edges are merged)\n    - **nx.MultiGraph**: Undirected multigraph (parallel edges preserved)\n    - **nx.MultiDiGraph**: Directed multigraph (parallel edges preserved)\n\n    **Attribute Handling:**\n    Node and edge attributes can be selectively included in the exported graph.\n    Internal columns (prefixed with '_') are available but typically excluded\n    from exports to maintain clean NetworkX compatibility.\n\n    Args:\n        graph_type: NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)\n        incl_node_attributes: Controls which node attributes to include:\n            - False: No attributes (only node IDs)\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        incl_edge_attributes: Controls which edge attributes to include:\n            - False: No attributes\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        omit_self_loops: If True, edges where source equals target are excluded\n\n    Returns:\n        NETWORKX_GRAPH_TYPE: NetworkX graph instance of the specified type\n\n    Note:\n        When exporting to simple graph types (Graph, DiGraph), parallel edges\n        are automatically merged. Use MultiGraph or MultiDiGraph to preserve\n        all edge instances.\n    \"\"\"\n\n    graph: NETWORKX_GRAPH_TYPE = graph_type()\n\n    def add_node(_node_id: int, **attrs):\n        graph.add_node(_node_id, **attrs)\n\n    def add_edge(_source: int, _target: int, **attrs):\n        graph.add_edge(_source, _target, **attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.NetworkData.as_rustworkx_graph","title":"<code>as_rustworkx_graph(graph_type: Type[RUSTWORKX_GRAPH_TYPE], multigraph: bool = False, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False, attach_node_id_map: bool = False) -&gt; RUSTWORKX_GRAPH_TYPE</code>","text":"<p>Export the network data as a RustWorkX graph object.</p> <p>RustWorkX provides high-performance graph algorithms implemented in Rust with Python bindings. This method converts NetworkData to RustWorkX format while handling the differences in node ID management between the two systems.</p> <p>Supported Graph Types: - rx.PyGraph: Undirected graph (with optional multigraph support) - rx.PyDiGraph: Directed graph (with optional multigraph support)</p> <p>Node ID Mapping: RustWorkX uses sequential integer node IDs starting from 0, which may differ from the original NetworkData node IDs. The original '_node_id' values are preserved as node attributes, and an optional mapping can be attached to the graph for reference.</p> <p>Performance Benefits: RustWorkX graphs offer significant performance advantages for: - Large-scale graph algorithms - Parallel processing - Memory-efficient operations - High-performance centrality calculations</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[RUSTWORKX_GRAPH_TYPE]</code> <p>RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)</p> required <code>multigraph</code> <code>bool</code> <p>If True, parallel edges are preserved; if False, they are merged</p> <code>False</code> <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which node attributes to include: - False: No attributes (only node data structure) - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which edge attributes to include: - False: No attributes - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>If True, self-loops (edges where source == target) are excluded</p> <code>False</code> <code>attach_node_id_map</code> <code>bool</code> <p>If True, adds a 'node_id_map' attribute to the graph containing the mapping from RustWorkX node IDs to original NetworkData node IDs</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RUSTWORKX_GRAPH_TYPE</code> <code>RUSTWORKX_GRAPH_TYPE</code> <p>RustWorkX graph instance of the specified type</p> Note <p>The original NetworkData '_node_id' values are always included in the node data dictionary, regardless of the incl_node_attributes setting.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_rustworkx_graph(\n    self,\n    graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n    multigraph: bool = False,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n    attach_node_id_map: bool = False,\n) -&gt; RUSTWORKX_GRAPH_TYPE:\n    \"\"\"Export the network data as a RustWorkX graph object.\n\n    RustWorkX provides high-performance graph algorithms implemented in Rust with\n    Python bindings. This method converts NetworkData to RustWorkX format while\n    handling the differences in node ID management between the two systems.\n\n    **Supported Graph Types:**\n    - **rx.PyGraph**: Undirected graph (with optional multigraph support)\n    - **rx.PyDiGraph**: Directed graph (with optional multigraph support)\n\n    **Node ID Mapping:**\n    RustWorkX uses sequential integer node IDs starting from 0, which may differ\n    from the original NetworkData node IDs. The original '_node_id' values are\n    preserved as node attributes, and an optional mapping can be attached to\n    the graph for reference.\n\n    **Performance Benefits:**\n    RustWorkX graphs offer significant performance advantages for:\n    - Large-scale graph algorithms\n    - Parallel processing\n    - Memory-efficient operations\n    - High-performance centrality calculations\n\n    Args:\n        graph_type: RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)\n        multigraph: If True, parallel edges are preserved; if False, they are merged\n        incl_node_attributes: Controls which node attributes to include:\n            - False: No attributes (only node data structure)\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        incl_edge_attributes: Controls which edge attributes to include:\n            - False: No attributes\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        omit_self_loops: If True, self-loops (edges where source == target) are excluded\n        attach_node_id_map: If True, adds a 'node_id_map' attribute to the graph\n            containing the mapping from RustWorkX node IDs to original NetworkData node IDs\n\n    Returns:\n        RUSTWORKX_GRAPH_TYPE: RustWorkX graph instance of the specified type\n\n    Note:\n        The original NetworkData '_node_id' values are always included in the\n        node data dictionary, regardless of the incl_node_attributes setting.\n    \"\"\"\n\n    from bidict import bidict\n\n    graph = graph_type(multigraph=multigraph)\n\n    # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n    # include node attributes)\n\n    self._calculate_node_attributes(incl_node_attributes)[1:]\n    self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n    # we can use a 'global' dict here because we know the nodes are processed before the edges\n    node_map: bidict = bidict()\n\n    def add_node(_node_id: int, **attrs):\n        data = {NODE_ID_COLUMN_NAME: _node_id}\n        data.update(attrs)\n\n        graph_node_id = graph.add_node(data)\n\n        node_map[graph_node_id] = _node_id\n        # if not _node_id == graph_node_id:\n        #     raise Exception(\"Internal error: node ids don't match\")\n\n    def add_edge(_source: int, _target: int, **attrs):\n        source = node_map[_source]\n        target = node_map[_target]\n        if not attrs:\n            graph.add_edge(source, target, None)\n        else:\n            graph.add_edge(source, target, attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    if attach_node_id_map:\n        graph.attrs = {\"node_id_map\": node_map}  # type: ignore\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.guess_node_id_column_name","title":"<code>guess_node_id_column_name(nodes_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_node_id_column_name(\n    nodes_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = NODE_ID_ALIAS_NAMES\n    return guess_column_name(table=nodes_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.guess_node_label_column_name","title":"<code>guess_node_label_column_name(nodes_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_node_label_column_name(\n    nodes_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = LABEL_ALIAS_NAMES\n    return guess_column_name(table=nodes_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.guess_source_column_name","title":"<code>guess_source_column_name(edges_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_source_column_name(\n    edges_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = SOURCE_COLUMN_ALIAS_NAMES\n    return guess_column_name(table=edges_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.guess_target_column_name","title":"<code>guess_target_column_name(edges_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_target_column_name(\n    edges_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = TARGET_COLUMN_ALIAS_NAMES\n    return guess_column_name(table=edges_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/__init__/#kiara_plugin.network_analysis.get_version","title":"<code>get_version() -&gt; str</code>","text":"<p>Get the current version of the <code>kiara_plugin.network_analysis</code> module.</p> <p>This tries to get the version from the current git commit or tag, if possible.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The version string.</p> Source code in <code>src/kiara_plugin/network_analysis/__init__.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"Get the current version of the `kiara_plugin.network_analysis` module.\n\n    This tries to get the version from the current git commit or tag, if possible.\n\n    Returns:\n        str: The version string.\n\n    \"\"\"\n\n    from importlib.metadata import PackageNotFoundError, version\n\n    try:\n        # Change here if project is renamed and does not equal the package name\n        dist_name = __name__\n        __version__ = version(dist_name)\n    except PackageNotFoundError:\n        try:\n            version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n\n            if os.path.exists(version_file):\n                with open(version_file, encoding=\"utf-8\") as vf:\n                    __version__ = vf.read()\n            else:\n                __version__ = \"unknown\"\n\n        except Exception:\n            pass\n\n        if __version__ is None:\n            __version__ = \"unknown\"\n\n    return __version__\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/","title":"data_types","text":"<p>This module contains the value type classes that are used in the <code>kiara_plugin.network_analysis</code> package.</p>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType","title":"<code>NetworkDataType</code>","text":"<p>               Bases: <code>TablesType</code></p> <p>Data that can be assembled into a graph.</p> <p>This data type extends the 'tables' type from the kiara_plugin.tabular plugin, restricting the allowed tables to one called 'edges', and one called 'nodes'.</p> Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>class NetworkDataType(TablesType):\n    \"\"\"Data that can be assembled into a graph.\n\n    This data type extends the 'tables' type from the [kiara_plugin.tabular](https://github.com/DHARPA-Project/kiara_plugin.tabular) plugin, restricting the allowed tables to one called 'edges',\n    and one called 'nodes'.\n    \"\"\"\n\n    _data_type_name: ClassVar[str] = \"network_data\"\n    _cached_doc: ClassVar[Union[str, None]] = None\n\n    @classmethod\n    def python_class(cls) -&gt; Type:\n        return NetworkData  # type: ignore\n\n    @classmethod\n    def type_doc(cls) -&gt; str:\n        if cls._cached_doc:\n            return cls._cached_doc\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        edge_properties = {}\n        edge_properties[EDGE_ID_COLUMN_NAME] = EDGE_ID_COLUMN_METADATA.doc.full_doc\n        edge_properties[SOURCE_COLUMN_NAME] = EDGE_SOURCE_COLUMN_METADATA.doc.full_doc\n        edge_properties[TARGET_COLUMN_NAME] = EDGE_TARGET_COLUMN_METADATA.doc.full_doc\n        edge_properties[COUNT_DIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_DIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n\n        properties_node = {}\n        properties_node[NODE_ID_COLUMN_NAME] = NODE_ID_COLUMN_METADATA.doc.full_doc\n        properties_node[LABEL_COLUMN_NAME] = NODE_LABEL_COLUMN_METADATA.doc.full_doc\n        properties_node[CONNECTIONS_COLUMN_NAME] = (\n            NODE_COUNT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[CONNECTIONS_MULTI_COLUMN_NAME] = (\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n\n        edge_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in edge_properties.items()\n        )\n        node_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in properties_node.items()\n        )\n\n        doc = cls.__doc__\n        doc_tables = f\"\"\"\n\n## Edges\nThe 'edges' table contains the following columns:\n\n{edge_properties_str}\n\n## Nodes\n\nThe 'nodes' table contains the following columns:\n\n{node_properties_str}\n\n\"\"\"\n\n        cls._cached_doc = f\"{doc}\\n\\n{doc_tables}\"\n        return cls._cached_doc\n\n    def parse_python_obj(self, data: Any) -&gt; NetworkData:\n        if isinstance(data, KiaraTables):\n            if EDGES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n                )\n\n            if NODES_TABLE_NAME not in data.tables.keys():\n                raise KiaraException(\n                    f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n                )\n\n            # return NetworkData(\n            #     tables={\n            #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n            #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n            #     },\n            #\n            # )\n            return NetworkData.create_network_data(\n                edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n                nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n                augment_tables=False,\n            )\n\n        if not isinstance(data, NetworkData):\n            raise KiaraException(\n                f\"Can't parse object to network data: invalid type '{type(data)}'.\"\n            )\n\n        return data\n\n    def _validate(cls, value: Any) -&gt; None:\n        if not isinstance(value, NetworkData):\n            raise ValueError(\n                f\"Invalid type '{type(value)}': must be of 'NetworkData' (or a sub-class).\"\n            )\n\n        network_data: NetworkData = value\n\n        table_names = network_data.table_names\n        if EDGES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{EDGES_TABLE_NAME}'.\"\n            )\n        if NODES_TABLE_NAME not in table_names:\n            raise Exception(\n                f\"Invalid 'network_data' value: database does not contain table '{NODES_TABLE_NAME}'.\"\n            )\n\n        edges_columns = network_data.edges.column_names\n        if SOURCE_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{SOURCE_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n        if TARGET_COLUMN_NAME not in edges_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'edges' table does not contain a '{TARGET_COLUMN_NAME}' column. Available columns: {', '.join(edges_columns)}.\"\n            )\n\n        nodes_columns = network_data.nodes.column_names\n        if NODE_ID_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{NODE_ID_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n        if LABEL_COLUMN_NAME not in nodes_columns:\n            raise Exception(\n                f\"Invalid 'network_data' value: 'nodes' table does not contain a '{LABEL_COLUMN_NAME}' column. Available columns: {', '.join(nodes_columns)}.\"\n            )\n\n    def pretty_print_as__terminal_renderable(\n        self, value: Value, render_config: Mapping[str, Any]\n    ) -&gt; Any:\n        max_rows = render_config.get(\n            \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n        )\n        max_row_height = render_config.get(\n            \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n        )\n        max_cell_length = render_config.get(\n            \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n        )\n\n        half_lines: Union[int, None] = None\n        if max_rows:\n            half_lines = int(max_rows / 2)\n\n        network_data: NetworkData = value.data\n\n        result: List[Any] = [\"\"]\n\n        nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n        nodes_pretty = nodes_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n        result.append(nodes_pretty)\n\n        edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n        edges_pretty = edges_atw.as_terminal_renderable(\n            rows_head=half_lines,\n            rows_tail=half_lines,\n            max_row_height=max_row_height,\n            max_cell_length=max_cell_length,\n        )\n        result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n        result.append(edges_pretty)\n\n        return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.python_class","title":"<code>python_class() -&gt; Type</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>@classmethod\ndef python_class(cls) -&gt; Type:\n    return NetworkData  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.type_doc","title":"<code>type_doc() -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>    @classmethod\n    def type_doc(cls) -&gt; str:\n        if cls._cached_doc:\n            return cls._cached_doc\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        edge_properties = {}\n        edge_properties[EDGE_ID_COLUMN_NAME] = EDGE_ID_COLUMN_METADATA.doc.full_doc\n        edge_properties[SOURCE_COLUMN_NAME] = EDGE_SOURCE_COLUMN_METADATA.doc.full_doc\n        edge_properties[TARGET_COLUMN_NAME] = EDGE_TARGET_COLUMN_METADATA.doc.full_doc\n        edge_properties[COUNT_DIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_DIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n        edge_properties[COUNT_IDX_UNDIRECTED_COLUMN_NAME] = (\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA.doc.full_doc\n        )\n\n        properties_node = {}\n        properties_node[NODE_ID_COLUMN_NAME] = NODE_ID_COLUMN_METADATA.doc.full_doc\n        properties_node[LABEL_COLUMN_NAME] = NODE_LABEL_COLUMN_METADATA.doc.full_doc\n        properties_node[CONNECTIONS_COLUMN_NAME] = (\n            NODE_COUNT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[CONNECTIONS_MULTI_COLUMN_NAME] = (\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[IN_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA.doc.full_doc\n        )\n        properties_node[OUT_DIRECTED_MULTI_COLUMN_NAME] = (\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA.doc.full_doc\n        )\n\n        edge_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in edge_properties.items()\n        )\n        node_properties_str = \"\\n\\n\".join(\n            f\"***{key}***:\\n\\n{value}\" for key, value in properties_node.items()\n        )\n\n        doc = cls.__doc__\n        doc_tables = f\"\"\"\n\n## Edges\nThe 'edges' table contains the following columns:\n\n{edge_properties_str}\n\n## Nodes\n\nThe 'nodes' table contains the following columns:\n\n{node_properties_str}\n\n\"\"\"\n\n        cls._cached_doc = f\"{doc}\\n\\n{doc_tables}\"\n        return cls._cached_doc\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.parse_python_obj","title":"<code>parse_python_obj(data: Any) -&gt; NetworkData</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def parse_python_obj(self, data: Any) -&gt; NetworkData:\n    if isinstance(data, KiaraTables):\n        if EDGES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{EDGES_TABLE_NAME}' table found\"\n            )\n\n        if NODES_TABLE_NAME not in data.tables.keys():\n            raise KiaraException(\n                f\"Can't import network data: no '{NODES_TABLE_NAME}' table found\"\n            )\n\n        # return NetworkData(\n        #     tables={\n        #         EDGES_TABLE_NAME: data.tables[EDGES_TABLE_NAME],\n        #         NODES_TABLE_NAME: data.tables[NODES_TABLE_NAME],\n        #     },\n        #\n        # )\n        return NetworkData.create_network_data(\n            edges_table=data.tables[EDGES_TABLE_NAME].arrow_table,\n            nodes_table=data.tables[NODES_TABLE_NAME].arrow_table,\n            augment_tables=False,\n        )\n\n    if not isinstance(data, NetworkData):\n        raise KiaraException(\n            f\"Can't parse object to network data: invalid type '{type(data)}'.\"\n        )\n\n    return data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/data_types/#kiara_plugin.network_analysis.data_types.NetworkDataType.pretty_print_as__terminal_renderable","title":"<code>pretty_print_as__terminal_renderable(value: Value, render_config: Mapping[str, Any]) -&gt; Any</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/data_types.py</code> <pre><code>def pretty_print_as__terminal_renderable(\n    self, value: Value, render_config: Mapping[str, Any]\n) -&gt; Any:\n    max_rows = render_config.get(\n        \"max_no_rows\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_no_rows\"]\n    )\n    max_row_height = render_config.get(\n        \"max_row_height\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_row_height\"]\n    )\n    max_cell_length = render_config.get(\n        \"max_cell_length\", DEFAULT_PRETTY_PRINT_CONFIG[\"max_cell_length\"]\n    )\n\n    half_lines: Union[int, None] = None\n    if max_rows:\n        half_lines = int(max_rows / 2)\n\n    network_data: NetworkData = value.data\n\n    result: List[Any] = [\"\"]\n\n    nodes_atw = ArrowTabularWrap(network_data.nodes.arrow_table)\n    nodes_pretty = nodes_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{NODES_TABLE_NAME}[/b]\")\n    result.append(nodes_pretty)\n\n    edges_atw = ArrowTabularWrap(network_data.edges.arrow_table)\n    edges_pretty = edges_atw.as_terminal_renderable(\n        rows_head=half_lines,\n        rows_tail=half_lines,\n        max_row_height=max_row_height,\n        max_cell_length=max_cell_length,\n    )\n    result.append(f\"[b]{EDGES_TABLE_NAME}[/b]\")\n    result.append(edges_pretty)\n\n    return Group(*result)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/","title":"defaults","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_COLUMN_NAME","title":"<code>NODE_ID_COLUMN_NAME = '_node_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_ID_COLUMN_NAME","title":"<code>EDGE_ID_COLUMN_NAME = '_edge_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_NAME","title":"<code>SOURCE_COLUMN_NAME = '_source'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_NAME","title":"<code>TARGET_COLUMN_NAME = '_target'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_COLUMN_NAME","title":"<code>LABEL_COLUMN_NAME = '_label'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COMPONENT_ID_COLUMN_NAME","title":"<code>COMPONENT_ID_COLUMN_NAME = '_component_id'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IS_CUTPOINT_COLUMN_NAME","title":"<code>IS_CUTPOINT_COLUMN_NAME = 'is_cut_point'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGES_TABLE_NAME","title":"<code>EDGES_TABLE_NAME = 'edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODES_TABLE_NAME","title":"<code>NODES_TABLE_NAME = 'nodes'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.DEFAULT_NETWORK_DATA_CHUNK_SIZE","title":"<code>DEFAULT_NETWORK_DATA_CHUNK_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_ALIAS_NAMES","title":"<code>NODE_ID_ALIAS_NAMES = ['id', 'node_id']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.LABEL_ALIAS_NAMES","title":"<code>LABEL_ALIAS_NAMES = ['label', 'node_label']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.SOURCE_COLUMN_ALIAS_NAMES","title":"<code>SOURCE_COLUMN_ALIAS_NAMES = ['source', 'sources', 'source_id', 'from', 'sender']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.TARGET_COLUMN_ALIAS_NAMES","title":"<code>TARGET_COLUMN_ALIAS_NAMES = ['target', 'targets', 'target_id', 'to', 'receiver']</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ATTRIBUTE_PROPERTY_KEY","title":"<code>ATTRIBUTE_PROPERTY_KEY = 'attribute_property'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_DIRECTED_COLUMN_NAME","title":"<code>COUNT_DIRECTED_COLUMN_NAME = '_count_dup_directed'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_UNDIRECTED_COLUMN_NAME","title":"<code>COUNT_UNDIRECTED_COLUMN_NAME = '_count_dup_undirected'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_IDX_DIRECTED_COLUMN_NAME","title":"<code>COUNT_IDX_DIRECTED_COLUMN_NAME = '_idx_dup_directed'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.COUNT_IDX_UNDIRECTED_COLUMN_NAME","title":"<code>COUNT_IDX_UNDIRECTED_COLUMN_NAME = '_idx_dup_undirected'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IN_DIRECTED_COLUMN_NAME","title":"<code>IN_DIRECTED_COLUMN_NAME = '_in_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.OUT_DIRECTED_COLUMN_NAME","title":"<code>OUT_DIRECTED_COLUMN_NAME = '_out_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.CONNECTIONS_COLUMN_NAME","title":"<code>CONNECTIONS_COLUMN_NAME = '_count_edges'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.IN_DIRECTED_MULTI_COLUMN_NAME","title":"<code>IN_DIRECTED_MULTI_COLUMN_NAME = '_in_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.OUT_DIRECTED_MULTI_COLUMN_NAME","title":"<code>OUT_DIRECTED_MULTI_COLUMN_NAME = '_out_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.CONNECTIONS_MULTI_COLUMN_NAME","title":"<code>CONNECTIONS_MULTI_COLUMN_NAME = '_count_edges_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_TABLE_NAME","title":"<code>RANKING_TABLE_NAME = 'ranking'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_COLUNN_NAME","title":"<code>RANKING_COLUNN_NAME = '_rank'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.RANKING_VALUE_COLUMN_NAME","title":"<code>RANKING_VALUE_COLUMN_NAME = '_value'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AUTO_CALCULATED_EDGE_COLUMNS","title":"<code>AUTO_CALCULATED_EDGE_COLUMNS = [EDGE_ID_COLUMN_NAME, SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME, COUNT_DIRECTED_COLUMN_NAME, COUNT_IDX_DIRECTED_COLUMN_NAME, COUNT_UNDIRECTED_COLUMN_NAME, COUNT_IDX_UNDIRECTED_COLUMN_NAME]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AUTO_CALCULATED_NODE_COLUMNS","title":"<code>AUTO_CALCULATED_NODE_COLUMNS = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME, IN_DIRECTED_COLUMN_NAME, OUT_DIRECTED_COLUMN_NAME, IN_DIRECTED_MULTI_COLUMN_NAME, OUT_DIRECTED_MULTI_COLUMN_NAME]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_ID_TEXT","title":"<code>NODE_ID_TEXT = 'The unique id for the node.\\n\\nThis is a unique integer identifier (counting up from 0) and is automatically generated by kiara, for each `network_data` value.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_LABEL_TEXT","title":"<code>NODE_LABEL_TEXT = \"The label for the node.\\n\\nThis is a (potentially non-unique) (ideally) human meaningful lable for the node, mostly used in visualizations. Depending on\\nhow the 'network_data' was created, this could be a name, title, etc. If no such label was available or specified\\nby the user, the node id will be used as label.\\n\"</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_EDGES_TEXT","title":"<code>NODE_COUNT_EDGES_TEXT = 'The number of edges that are connected to this node if the network_data is interpreted as a non-multi graph\\n\\nBoth incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs.\\n.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_EDGES_MULTI_TEXT = 'The number of edges that are connected to this node if the network_data is interpreted as a multi graph\\n\\nBoth incoming and outgoing edges are counted, which means that the number is valid for both directed and undirected graphs.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_IN_EDGES_TEXT","title":"<code>NODE_COUNT_IN_EDGES_TEXT = 'The number of incoming edges that are connected to this node if the network_data is interpreted as a non-multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_IN_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_IN_EDGES_MULTI_TEXT = 'The number of incoming edges that are connected to this node if the network_data is interpreted as a multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_OUT_EDGES_TEXT","title":"<code>NODE_COUNT_OUT_EDGES_TEXT = 'The number of outgoing edges that are connected to this node if the network_data is interpreted as a non-multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NODE_COUNT_OUT_EDGES_MULTI_TEXT","title":"<code>NODE_COUNT_OUT_EDGES_MULTI_TEXT = 'The number of outgoing edges that are connected to this node if the network_data is interpreted as a multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_ID_TEXT","title":"<code>EDGE_ID_TEXT = 'The unique id for the edge.\\n\\nThis is a unique integer identifier (counting up from 0) and is automatically generated by kiara, for each `network_data` value.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_SOURCE_TEXT","title":"<code>EDGE_SOURCE_TEXT = 'The node id of the source for an edge.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_TARGET_TEXT","title":"<code>EDGE_TARGET_TEXT = 'The node id of the target for an edge.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_COUNT_DUP_DIRECTED_TEXT","title":"<code>EDGE_COUNT_DUP_DIRECTED_TEXT = 'The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as directed multi graph.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_IDX_DUP_DIRECTED_TEXT","title":"<code>EDGE_IDX_DUP_DIRECTED_TEXT = 'A unique index for this edge within its set of duplicates, if the network_data is interpreted as directed multi graph.\\n\\nThis is a unique integer identifier in combination with (_source/_target), counting up from 1. The order of the edges within this set is not guaranteed.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_COUNT_DUP_UNDIRECTED_TEXT","title":"<code>EDGE_COUNT_DUP_UNDIRECTED_TEXT = 'The number of edges that have the same source/target combination as this (incl. this), if the network_data is interpreted as undirected multi graph.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.EDGE_IDX_DUP_UNDIRECTED_TEXT","title":"<code>EDGE_IDX_DUP_UNDIRECTED_TEXT = 'A unique index for this edge within its set of duplicates, if the network_data is interpreted as undirected multi graph.\\n\\nThis is a unique integer identifier in combination with (_source/_target), counting up from 1. The order of the edges within this set is not guaranteed.\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.ALLOWED_AGGREGATION_FUNCTIONS","title":"<code>ALLOWED_AGGREGATION_FUNCTIONS = {'group_by': \"Don't aggregate on this column, but keep it as is and use it in the group by clause.\", 'any_val': 'Returns the first non-null value', 'avg': 'Calculates the average value for all tuples in arg.', 'bool_and': 'Returns TRUE if every input value is TRUE, otherwise FALSE.', 'bool_or': 'Returns TRUE if any input value is TRUE, otherwise FALSE.', 'count': 'Returns the number of input values.', 'favg': 'Calculates the average using a more accurate floating point summation (Kahan Sum).', 'first': 'Returns the first value of a column.', 'fsum': 'Calculates the sum using a more accurate floating point summation (Kahan Sum).', 'histogram': 'Returns a LIST of STRUCTs with the fields bucket and count.', 'last': 'Returns the last value of a column.', 'list': 'Returns a LIST containing all the values of a column.', 'max': 'Returns the maximum value present in the column.', 'min': 'Returns the minimum value present in the column.', 'product': 'Returns the product of all tuples in the column.', 'string_agg_comma': 'Concatenates the column string values with a comma separator.', 'sum': 'Calculates the sum value for all tuples in arg.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.AGGREGATION_FUNCTION_NAME","title":"<code>AGGREGATION_FUNCTION_NAME = Literal[tuple(ALLOWED_AGGREGATION_FUNCTIONS.keys())]</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.DEFAULT_UNWEIGHTED_NODE_DEGREE_COLUMN_NAME","title":"<code>DEFAULT_UNWEIGHTED_NODE_DEGREE_COLUMN_NAME = '_degree_unweighted'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.UNWEIGHTED_NODE_DEGREE_TEXT","title":"<code>UNWEIGHTED_NODE_DEGREE_TEXT = 'The degree of a node is the number of edges connected to the node.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME","title":"<code>UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME = '_degree_centrality'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME","title":"<code>UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME = '_degree_centrality_multi'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.UNWEIGHTED_DEGREE_CENTRALITY_TEXT","title":"<code>UNWEIGHTED_DEGREE_CENTRALITY_TEXT = 'The degree centrality values are normalized by dividing the degree of a node by the maximum possible degree in a simple graph n-1 where n is the number of nodes in the graph. For multigraphs or graphs with self loops the maximum degree might be higher than n-1 and values of degree centrality greater than 1 are possible.'</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType","title":"<code>NetworkDataTableType</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/kiara_plugin/network_analysis/defaults.py</code> <pre><code>class NetworkDataTableType(Enum):\n    EDGES = EDGES_TABLE_NAME\n    NODES = NODES_TABLE_NAME\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.EDGES","title":"<code>EDGES = EDGES_TABLE_NAME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.NetworkDataTableType.NODES","title":"<code>NODES = NODES_TABLE_NAME</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType","title":"<code>GraphType</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/kiara_plugin/network_analysis/defaults.py</code> <pre><code>class GraphType(Enum):\n    UNDIRECTED = \"undirected\"\n    DIRECTED = \"directed\"\n    DIRECTED_MULTI = \"directed_multi\"\n    UNDIRECTED_MULTI = \"undirected_multi\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.UNDIRECTED","title":"<code>UNDIRECTED = 'undirected'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.DIRECTED","title":"<code>DIRECTED = 'directed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.DIRECTED_MULTI","title":"<code>DIRECTED_MULTI = 'directed_multi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/defaults/#kiara_plugin.network_analysis.defaults.GraphType.UNDIRECTED_MULTI","title":"<code>UNDIRECTED_MULTI = 'undirected_multi'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/","title":"models","text":"<p>This module contains the metadata (and other) models that are used in the <code>kiara_plugin.network_analysis</code> package.</p> <p>Those models are convenience wrappers that make it easier for kiara to find, create, manage and version metadata -- but also other type of models -- that is attached to data, as well as kiara modules.</p> <p>Metadata models must be a sub-class of [kiara.metadata.MetadataModel][]. Other models usually sub-class a pydantic BaseModel or implement custom base classes.</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NETWORKX_GRAPH_TYPE","title":"<code>NETWORKX_GRAPH_TYPE = TypeVar('NETWORKX_GRAPH_TYPE', bound='nx.Graph')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.RUSTWORKX_GRAPH_TYPE","title":"<code>RUSTWORKX_GRAPH_TYPE = TypeVar('RUSTWORKX_GRAPH_TYPE', 'rx.PyGraph', 'rx.PyDiGraph')</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NodesCallback","title":"<code>NodesCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NodesCallback(Protocol):\n    def __call__(self, _node_id: int, **kwargs) -&gt; None: ...\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.EdgesCallback","title":"<code>EdgesCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class EdgesCallback(Protocol):\n    def __call__(self, _source: int, _target: int, **kwargs) -&gt; None: ...\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData","title":"<code>NetworkData</code>","text":"<p>               Bases: <code>KiaraTables</code></p> <p>A flexible, graph-type agnostic wrapper class for network datasets.</p> <p>This class provides a unified interface for working with network data that can represent any type of graph structure: directed, undirected, simple, or multi-graphs. The design philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.</p> <p>Design Philosophy: - Graph Type Agnostic: Supports all graph types (directed/undirected, simple/multi)   within the same data structure without requiring type-specific conversions - Efficient Storage: Uses Apache Arrow tables for high-performance columnar storage - Flexible Querying: Provides SQL-based querying capabilities alongside programmatic access - Seamless Export: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future - Metadata Rich: Automatically computes and stores graph statistics and properties</p> <p>Internal Structure: The network data is stored as two Arrow tables: - nodes table: Contains node information with required columns '_node_id' (int) and '_label' (str) - edges table: Contains edge information with required columns '_source' (int) and '_target' (int)</p> <p>Additional computed columns (prefixed with '_') provide graph statistics for different interpretations: - Degree counts for directed/undirected graphs - Multi-edge counts and indices - Centrality measures</p> <p>Graph Type Support: - Simple Graphs: Single edges between node pairs - Multi-graphs: Multiple edges between the same node pairs - Directed Graphs: One-way edges with source \u2192 target semantics - Undirected Graphs: Bidirectional edges - Mixed Types: The same data can be interpreted as different graph types</p> <p>Note: Column names prefixed with '_' have internal meaning and are automatically computed. Original attributes from source data are stored without the prefix.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NetworkData(KiaraTables):\n    \"\"\"A flexible, graph-type agnostic wrapper class for network datasets.\n\n    This class provides a unified interface for working with network data that can represent\n    any type of graph structure: directed, undirected, simple, or multi-graphs. The design\n    philosophy emphasizes flexibility and performance while maintaining a clean, intuitive API.\n\n    **Design Philosophy:**\n    - **Graph Type Agnostic**: Supports all graph types (directed/undirected, simple/multi)\n      within the same data structure without requiring type-specific conversions\n    - **Efficient Storage**: Uses Apache Arrow tables for high-performance columnar storage\n    - **Flexible Querying**: Provides SQL-based querying capabilities alongside programmatic access\n    - **Seamless Export**: Easy conversion to NetworkX and RustWorkX graph objects, other representations possible in the future\n    - **Metadata Rich**: Automatically computes and stores graph statistics and properties\n\n    **Internal Structure:**\n    The network data is stored as two Arrow tables:\n    - **nodes table**: Contains node information with required columns '_node_id' (int) and '_label' (str)\n    - **edges table**: Contains edge information with required columns '_source' (int) and '_target' (int)\n\n    Additional computed columns (prefixed with '_') provide graph statistics for different interpretations:\n    - Degree counts for directed/undirected graphs\n    - Multi-edge counts and indices\n    - Centrality measures\n\n    **Graph Type Support:**\n    - **Simple Graphs**: Single edges between node pairs\n    - **Multi-graphs**: Multiple edges between the same node pairs\n    - **Directed Graphs**: One-way edges with source \u2192 target semantics\n    - **Undirected Graphs**: Bidirectional edges\n    - **Mixed Types**: The same data can be interpreted as different graph types\n\n    **Note:** Column names prefixed with '_' have internal meaning and are automatically\n    computed. Original attributes from source data are stored without the prefix.\n    \"\"\"\n\n    _kiara_model_id: ClassVar = \"instance.network_data\"\n\n    @classmethod\n    def create_augmented(\n        cls,\n        network_data: \"NetworkData\",\n        additional_edges_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n        additional_nodes_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n        nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n        edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a new NetworkData instance with additional columns.\n\n        This method creates a new NetworkData instance by adding extra columns to an existing\n        instance without recomputing the automatically generated internal columns (those\n        prefixed with '_'). This is useful for adding derived attributes or analysis results.\n\n        Args:\n            network_data: The source NetworkData instance to augment\n            additional_edges_columns: Dictionary mapping column names to PyArrow Arrays\n                for new edge attributes\n            additional_nodes_columns: Dictionary mapping column names to PyArrow Arrays\n                for new node attributes\n            nodes_column_metadata: Additional metadata to attach to nodes table columns\n            edges_column_metadata: Additional metadata to attach to edges table columns\n\n        Returns:\n            NetworkData: A new NetworkData instance with the additional columns\n\n        Example:\n            ```python\n            import pyarrow as pa\n\n            # Add a weight column to edges\n            weights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\n            augmented = NetworkData.create_augmented(\n                network_data,\n                additional_edges_columns={\"weight\": weights}\n            )\n            ```\n        \"\"\"\n\n        nodes_table = network_data.nodes.arrow_table\n        edges_table = network_data.edges.arrow_table\n\n        # nodes_table = pa.Table.from_arrays(orig_nodes_table.columns, schema=orig_nodes_table.schema)\n        # edges_table = pa.Table.from_arrays(orig_edges_table.columns, schema=orig_edges_table.schema)\n\n        if additional_edges_columns is not None:\n            for col_name, col_data in additional_edges_columns.items():\n                edges_table = edges_table.append_column(col_name, col_data)\n\n        if additional_nodes_columns is not None:\n            for col_name, col_data in additional_nodes_columns.items():\n                nodes_table = nodes_table.append_column(col_name, col_data)\n\n        new_network_data = NetworkData.create_network_data(\n            nodes_table=nodes_table,\n            edges_table=edges_table,\n            augment_tables=False,\n            nodes_column_metadata=nodes_column_metadata,\n            edges_column_metadata=edges_column_metadata,\n        )\n\n        return new_network_data\n\n    @classmethod\n    def create_network_data(\n        cls,\n        nodes_table: \"pa.Table\",\n        edges_table: \"pa.Table\",\n        augment_tables: bool = True,\n        nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n        edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a NetworkData instance from PyArrow tables.\n\n        This is the primary factory method for creating NetworkData instances from raw tabular data.\n        It supports all graph types and automatically computes necessary metadata for efficient\n        graph operations.\n\n        **Required Table Structure:**\n\n        Nodes table must contain:\n        - '_node_id' (int): Unique integer identifier for each node\n        - '_label' (str): Human-readable label for the node\n\n        Edges table must contain:\n        - '_source' (int): Source node ID (must exist in nodes table)\n        - '_target' (int): Target node ID (must exist in nodes table)\n\n        **Automatic Augmentation:**\n        When `augment_tables=True` (default), the method automatically adds computed columns:\n\n        For edges:\n        - '_edge_id': Unique edge identifier\n        - '_count_dup_directed': Count of parallel edges (directed interpretation)\n        - '_idx_dup_directed': Index within parallel edge group (directed)\n        - '_count_dup_undirected': Count of parallel edges (undirected interpretation)\n        - '_idx_dup_undirected': Index within parallel edge group (undirected)\n\n        For nodes:\n        - '_count_edges': Total edge count (simple graph interpretation)\n        - '_count_edges_multi': Total edge count (multi-graph interpretation)\n        - '_in_edges': Incoming edge count (directed, simple)\n        - '_out_edges': Outgoing edge count (directed, simple)\n        - '_in_edges_multi': Incoming edge count (directed, multi)\n        - '_out_edges_multi': Outgoing edge count (directed, multi)\n        - '_degree_centrality': Normalized degree centrality\n        - '_degree_centrality_multi': Normalized degree centrality (multi-graph)\n\n        Args:\n            nodes_table: PyArrow table containing node data\n            edges_table: PyArrow table containing edge data\n            augment_tables: Whether to compute and add internal metadata columns.\n                Set to False only if you know the metadata is already present and correct.\n            nodes_column_metadata: Additional metadata to attach to nodes table columns.\n                Format: {column_name: {property_name: property_value}}\n            edges_column_metadata: Additional metadata to attach to edges table columns.\n                Format: {column_name: {property_name: property_value}}\n\n        Returns:\n            NetworkData: A new NetworkData instance\n\n        Raises:\n            KiaraException: If required columns are missing or contain null values\n\n        \"\"\"\n\n        from kiara_plugin.network_analysis.models.metadata import (\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_ID_COLUMN_METADATA,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            EDGE_SOURCE_COLUMN_METADATA,\n            EDGE_TARGET_COLUMN_METADATA,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            NODE_DEGREE_COLUMN_METADATA,\n            NODE_DEGREE_MULTI_COLUMN_METADATA,\n            NODE_ID_COLUMN_METADATA,\n            NODE_LABEL_COLUMN_METADATA,\n        )\n\n        if augment_tables:\n            edges_table = augment_edges_table_with_id_and_weights(edges_table)\n            nodes_table = augment_nodes_table_with_connection_counts(\n                nodes_table, edges_table\n            )\n            nodes_table, edges_table = augment_tables_with_component_ids(\n                nodes_table=nodes_table, edges_table=edges_table\n            )\n\n        if edges_table.column(SOURCE_COLUMN_NAME).null_count &gt; 0:\n            raise KiaraException(\n                msg=\"Can't assemble network data.\",\n                details=\"Source column in edges table contains null values.\",\n            )\n        if edges_table.column(TARGET_COLUMN_NAME).null_count &gt; 0:\n            raise KiaraException(\n                msg=\"Can't assemble network data.\",\n                details=\"Target column in edges table contains null values.\",\n            )\n\n        network_data: NetworkData = cls.create_tables(\n            {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n        )\n\n        # set default column metadata\n        network_data.edges.set_column_metadata(\n            EDGE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            SOURCE_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_SOURCE_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            TARGET_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_TARGET_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.edges.set_column_metadata(\n            COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        network_data.nodes.set_column_metadata(\n            NODE_ID_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_ID_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            LABEL_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_LABEL_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_DEGREE_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            CONNECTIONS_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_DEGREE_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            IN_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n        network_data.nodes.set_column_metadata(\n            OUT_DIRECTED_MULTI_COLUMN_NAME,\n            ATTRIBUTE_PROPERTY_KEY,\n            NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n            overwrite_existing=False,\n        )\n\n        if nodes_column_metadata is not None:\n            for col_name, col_meta in nodes_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.nodes.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n        if edges_column_metadata is not None:\n            for col_name, col_meta in edges_column_metadata.items():\n                for prop_name, prop_value in col_meta.items():\n                    network_data.edges.set_column_metadata(\n                        col_name, prop_name, prop_value, overwrite_existing=True\n                    )\n\n        return network_data\n\n    @classmethod\n    def from_filtered_nodes(\n        cls, network_data: \"NetworkData\", nodes_list: List[int]\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a new, filtered instance of this class using a source network, and a list of node ids to include.\n\n        Nodes/edges containing a node id not in the list will be removed from the resulting network data.\n\n        Arguments:\n            network_data: the source network data\n            nodes_list: the list of node ids to include in the filtered network data\n        \"\"\"\n\n        import duckdb\n        import polars as pl\n\n        node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        for column_name, metadata in network_data.nodes.column_metadata.items():\n            attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(  # type: ignore\n                ATTRIBUTE_PROPERTY_KEY, None\n            )\n            if attr_prop is None or not attr_prop.computed_attribute:\n                node_columns.append(column_name)\n\n        node_list_str = \", \".join([str(n) for n in nodes_list])\n\n        nodes_table = network_data.nodes.arrow_table  # noqa\n        nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n        nodes_result = duckdb.sql(nodes_query).pl()\n\n        edges_table = network_data.edges.arrow_table  # noqa\n        edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        for column_name, metadata in network_data.edges.column_metadata.items():\n            attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)  # type: ignore\n            if attr_prop is None or not attr_prop.computed_attribute:\n                edge_columns.append(column_name)\n\n        edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n        edges_result = duckdb.sql(edges_query).pl()\n\n        nodes_idx_colum = range(len(nodes_result))\n        old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n        repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n        nodes_result = nodes_result.with_columns(\n            pl.col(NODE_ID_COLUMN_NAME).replace_strict(repl_map, default=None)\n        )\n\n        edges_result = edges_result.with_columns(\n            pl.col(SOURCE_COLUMN_NAME).replace_strict(repl_map, default=None),\n            pl.col(TARGET_COLUMN_NAME).replace_strict(repl_map, default=None),\n        )\n\n        filtered = NetworkData.create_network_data(\n            nodes_table=nodes_result, edges_table=edges_result\n        )\n        return filtered\n\n    @classmethod\n    def create_from_networkx_graph(\n        cls,\n        graph: \"nx.Graph\",\n        label_attr_name: Union[str, None] = None,\n        ignore_node_attributes: Union[Iterable[str], None] = None,\n    ) -&gt; \"NetworkData\":\n        \"\"\"Create a NetworkData instance from any NetworkX graph type.\n\n        This method provides seamless conversion from NetworkX graphs to NetworkData,\n        preserving all node and edge attributes while automatically handling different\n        graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).\n\n        **Graph Type Support:**\n        - **nx.Graph**: Converted to undirected simple graph representation\n        - **nx.DiGraph**: Converted to directed simple graph representation\n        - **nx.MultiGraph**: Converted with multi-edge support (undirected)\n        - **nx.MultiDiGraph**: Converted with multi-edge support (directed)\n\n        **Attribute Handling:**\n        All NetworkX node and edge attributes are preserved as columns in the resulting\n        tables, except those starting with '_' (reserved for internal use).\n\n        Args:\n            graph: Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)\n            label_attr_name: Name of the node attribute to use as the node label.\n                If None, the node ID is converted to string and used as label.\n                Can also be an iterable of attribute names to try in order.\n            ignore_node_attributes: List of node attribute names to exclude from\n                the resulting nodes table\n\n        Returns:\n            NetworkData: A new NetworkData instance representing the graph\n\n        Raises:\n            KiaraException: If node/edge attributes contain names starting with '_'\n\n        Note:\n            Node IDs in the original NetworkX graph are mapped to sequential integers\n            starting from 0 in the NetworkData representation. The original node IDs\n            are preserved as the '_label' if no label_attr_name is specified.\n        \"\"\"\n\n        # TODO: should we also index nodes/edges attributes?\n\n        nodes_table, node_id_map = extract_networkx_nodes_as_table(\n            graph=graph,\n            label_attr_name=label_attr_name,\n            ignore_attributes=ignore_node_attributes,\n        )\n\n        edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes_table, edges_table=edges_table\n        )\n\n        return network_data\n\n    @property\n    def edges(self) -&gt; \"KiaraTable\":\n        \"\"\"Access the edges table containing all edge data and computed statistics.\n\n        The edges table contains both original edge attributes and computed columns:\n        - '_edge_id': Unique edge identifier\n        - '_source', '_target': Node IDs for edge endpoints\n        - '_count_dup_*': Parallel edge counts for different graph interpretations\n        - '_idx_dup_*': Indices within parallel edge groups\n        - Original edge attributes (without '_' prefix)\n\n        Returns:\n            KiaraTable: The edges table with full schema and data access methods\n        \"\"\"\n        return self.tables[EDGES_TABLE_NAME]\n\n    @property\n    def nodes(self) -&gt; \"KiaraTable\":\n        \"\"\"Access the nodes table containing all node data and computed statistics.\n\n        The nodes table contains both original node attributes and computed columns:\n        - '_node_id': Unique node identifier (sequential integers from 0)\n        - '_label': Human-readable node label\n        - '_count_edges*': Edge counts for different graph interpretations\n        - '_in_edges*', '_out_edges*': Directional edge counts\n        - '_degree_centrality*': Normalized degree centrality measures\n        - Original node attributes (without '_' prefix)\n\n        Returns:\n            KiaraTable: The nodes table with full schema and data access methods\n        \"\"\"\n        return self.tables[NODES_TABLE_NAME]\n\n    @property\n    def num_nodes(self) -&gt; int:\n        \"\"\"Get the total number of nodes in the network.\n\n        Returns:\n            int: Number of nodes in the network\n        \"\"\"\n        return self.nodes.num_rows  # type: ignore\n\n    @property\n    def num_edges(self) -&gt; int:\n        \"\"\"Get the total number of edges in the network.\n\n        Note: This returns the total number of edge records, which includes\n        all parallel edges in multi-graph interpretations.\n\n        Returns:\n            int: Total number of edges (including parallel edges)\n        \"\"\"\n        return self.edges.num_rows  # type: ignore\n\n    def query_edges(\n        self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n        \"\"\"Execute SQL queries on the edges table for flexible data analysis.\n\n        This method provides direct SQL access to the edges table, enabling complex\n        queries and aggregations. All computed edge columns are available for querying.\n\n        **Available Columns:**\n        - '_edge_id': Unique edge identifier\n        - '_source', '_target': Node IDs for edge endpoints\n        - '_count_dup_directed': Number of parallel edges (directed interpretation)\n        - '_idx_dup_directed': Index within parallel edge group (directed)\n        - '_count_dup_undirected': Number of parallel edges (undirected interpretation)\n        - '_idx_dup_undirected': Index within parallel edge group (undirected)\n        - Original edge attributes (names without '_' prefix)\n\n        Args:\n            sql_query: SQL query string. Use 'edges' as the table name in your query.\n            relation_name: Alternative table name to use in the query (default: 'edges').\n                If specified, all occurrences of this name in the query will be replaced\n                with 'edges'.\n\n        Returns:\n            pa.Table: Query results as a PyArrow table\n\n        Example:\n            ```python\n            # Find edges with high multiplicity\n            parallel_edges = network_data.query_edges(\n                \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n            )\n\n            # Get edge statistics\n            stats = network_data.query_edges(\n                \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n            )\n            ```\n        \"\"\"\n        import duckdb\n\n        con = duckdb.connect()\n        edges = self.edges.arrow_table  # noqa: F841\n        if relation_name != EDGES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def query_nodes(\n        self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n    ) -&gt; \"pa.Table\":\n        \"\"\"Execute SQL queries on the nodes table for flexible data analysis.\n\n        This method provides direct SQL access to the nodes table, enabling complex\n        queries and aggregations. All computed node statistics are available for querying.\n\n        **Available Columns:**\n        - '_node_id': Unique node identifier\n        - '_label': Human-readable node label\n        - '_count_edges': Total edge count (simple graph interpretation)\n        - '_count_edges_multi': Total edge count (multi-graph interpretation)\n        - '_in_edges': Incoming edge count (directed, simple)\n        - '_out_edges': Outgoing edge count (directed, simple)\n        - '_in_edges_multi': Incoming edge count (directed, multi)\n        - '_out_edges_multi': Outgoing edge count (directed, multi)\n        - '_degree_centrality': Normalized degree centrality (simple)\n        - '_degree_centrality_multi': Normalized degree centrality (multi)\n        - Original node attributes (names without '_' prefix)\n\n        Args:\n            sql_query: SQL query string. Use 'nodes' as the table name in your query.\n            relation_name: Alternative table name to use in the query (default: 'nodes').\n                If specified, all occurrences of this name in the query will be replaced\n                with 'nodes'.\n\n        Returns:\n            pa.Table: Query results as a PyArrow table\n\n        Example:\n            ```python\n            # Find high-degree nodes\n            hubs = network_data.query_nodes(\n                \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n            )\n\n            # Get centrality statistics\n            centrality_stats = network_data.query_nodes(\n                \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n            )\n            ```\n        \"\"\"\n        import duckdb\n\n        con = duckdb.connect()\n        nodes = self.nodes.arrow_table  # noqa\n        if relation_name != NODES_TABLE_NAME:\n            sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n        result = con.execute(sql_query)\n        return result.arrow()\n\n    def _calculate_node_attributes(\n        self, incl_node_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n        \"\"\"Calculate the node attributes that should be included in the output.\"\"\"\n\n        if incl_node_attributes is False:\n            node_attr_names: List[str] = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n        else:\n            all_node_attr_names: List[str] = self.nodes.column_names  # type: ignore\n            if incl_node_attributes is True:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                node_attr_names.extend(\n                    (x for x in all_node_attr_names if x != NODE_ID_COLUMN_NAME)\n                )  # type: ignore\n            elif isinstance(incl_node_attributes, str):\n                if incl_node_attributes not in all_node_attr_names:\n                    raise KiaraException(\n                        f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                    )\n                node_attr_names = [NODE_ID_COLUMN_NAME, incl_node_attributes]\n            else:\n                node_attr_names = [NODE_ID_COLUMN_NAME]\n                for attr_name in incl_node_attributes:\n                    if attr_name not in all_node_attr_names:\n                        raise KiaraException(\n                            f\"Can't include node attribute {incl_node_attributes}: not part of the available attributes ({', '.join(all_node_attr_names)}).\"\n                        )\n                    node_attr_names.append(attr_name)  # type: ignore\n\n        return node_attr_names\n\n    def _calculate_edge_attributes(\n        self, incl_edge_attributes: Union[bool, str, Iterable[str]]\n    ) -&gt; List[str]:\n        \"\"\"Calculate the edge attributes that should be included in the output.\"\"\"\n\n        if incl_edge_attributes is False:\n            edge_attr_names: List[str] = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        else:\n            all_edge_attr_names: List[str] = self.edges.column_names  # type: ignore\n            if incl_edge_attributes is True:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                edge_attr_names.extend(\n                    (\n                        x\n                        for x in all_edge_attr_names\n                        if x not in (SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME)\n                    )\n                )  # type: ignore\n            elif isinstance(incl_edge_attributes, str):\n                if incl_edge_attributes not in all_edge_attr_names:\n                    raise KiaraException(\n                        f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                    )\n                edge_attr_names = [\n                    SOURCE_COLUMN_NAME,\n                    TARGET_COLUMN_NAME,\n                    incl_edge_attributes,\n                ]\n            else:\n                edge_attr_names = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n                for attr_name in incl_edge_attributes:\n                    if attr_name not in all_edge_attr_names:\n                        raise KiaraException(\n                            f\"Can't include edge attribute {incl_edge_attributes}: not part of the available attributes ({', '.join(all_edge_attr_names)}).\"\n                        )\n                    edge_attr_names.append(attr_name)  # type: ignore\n\n        return edge_attr_names\n\n    def retrieve_graph_data(\n        self,\n        nodes_callback: Union[NodesCallback, None] = None,\n        edges_callback: Union[EdgesCallback, None] = None,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ):\n        \"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n        First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n        The nodes_callback will be called with the following arguments:\n            - node_id: the id of the node (int)\n            - if False: nothing else\n            - if True: all node attributes, in the order they are defined in the table schema\n            - if str: the value of the specified node attribute\n            - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n        The edges_callback will be called with the following aruments:\n            - source_id: the id of the source node (int)\n            - target_id: the id of the target node (int)\n            - if False: nothing else\n            - if True: all edge attributes, in the order they are defined in the table schema\n            - if str: the value of the specified edge attribute\n            - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n        \"\"\"\n\n        if nodes_callback is not None:\n            node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n            nodes_df = self.nodes.to_polars_dataframe()\n            for row in nodes_df.select(*node_attr_names).rows(named=True):\n                nodes_callback(**row)  # type: ignore\n\n        if edges_callback is not None:\n            edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n            edges_df = self.edges.to_polars_dataframe()\n            for row in edges_df.select(*edge_attr_names).rows(named=True):\n                if (\n                    omit_self_loops\n                    and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n                ):\n                    continue\n                edges_callback(**row)  # type: ignore\n\n    def as_networkx_graph(\n        self,\n        graph_type: Type[NETWORKX_GRAPH_TYPE],\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n    ) -&gt; NETWORKX_GRAPH_TYPE:\n        \"\"\"Export the network data as a NetworkX graph object.\n\n        This method converts the NetworkData to any NetworkX graph type, providing\n        flexibility to work with the data using NetworkX's extensive algorithm library.\n        The conversion preserves node and edge attributes as specified.\n\n        **Supported Graph Types:**\n        - **nx.Graph**: Undirected simple graph (parallel edges are merged)\n        - **nx.DiGraph**: Directed simple graph (parallel edges are merged)\n        - **nx.MultiGraph**: Undirected multigraph (parallel edges preserved)\n        - **nx.MultiDiGraph**: Directed multigraph (parallel edges preserved)\n\n        **Attribute Handling:**\n        Node and edge attributes can be selectively included in the exported graph.\n        Internal columns (prefixed with '_') are available but typically excluded\n        from exports to maintain clean NetworkX compatibility.\n\n        Args:\n            graph_type: NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)\n            incl_node_attributes: Controls which node attributes to include:\n                - False: No attributes (only node IDs)\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            incl_edge_attributes: Controls which edge attributes to include:\n                - False: No attributes\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            omit_self_loops: If True, edges where source equals target are excluded\n\n        Returns:\n            NETWORKX_GRAPH_TYPE: NetworkX graph instance of the specified type\n\n        Note:\n            When exporting to simple graph types (Graph, DiGraph), parallel edges\n            are automatically merged. Use MultiGraph or MultiDiGraph to preserve\n            all edge instances.\n        \"\"\"\n\n        graph: NETWORKX_GRAPH_TYPE = graph_type()\n\n        def add_node(_node_id: int, **attrs):\n            graph.add_node(_node_id, **attrs)\n\n        def add_edge(_source: int, _target: int, **attrs):\n            graph.add_edge(_source, _target, **attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        return graph\n\n    def as_rustworkx_graph(\n        self,\n        graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n        multigraph: bool = False,\n        incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n        incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n        omit_self_loops: bool = False,\n        attach_node_id_map: bool = False,\n    ) -&gt; RUSTWORKX_GRAPH_TYPE:\n        \"\"\"Export the network data as a RustWorkX graph object.\n\n        RustWorkX provides high-performance graph algorithms implemented in Rust with\n        Python bindings. This method converts NetworkData to RustWorkX format while\n        handling the differences in node ID management between the two systems.\n\n        **Supported Graph Types:**\n        - **rx.PyGraph**: Undirected graph (with optional multigraph support)\n        - **rx.PyDiGraph**: Directed graph (with optional multigraph support)\n\n        **Node ID Mapping:**\n        RustWorkX uses sequential integer node IDs starting from 0, which may differ\n        from the original NetworkData node IDs. The original '_node_id' values are\n        preserved as node attributes, and an optional mapping can be attached to\n        the graph for reference.\n\n        **Performance Benefits:**\n        RustWorkX graphs offer significant performance advantages for:\n        - Large-scale graph algorithms\n        - Parallel processing\n        - Memory-efficient operations\n        - High-performance centrality calculations\n\n        Args:\n            graph_type: RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)\n            multigraph: If True, parallel edges are preserved; if False, they are merged\n            incl_node_attributes: Controls which node attributes to include:\n                - False: No attributes (only node data structure)\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            incl_edge_attributes: Controls which edge attributes to include:\n                - False: No attributes\n                - True: All attributes (including computed columns)\n                - str: Single attribute name to include\n                - Iterable[str]: List of specific attributes to include\n            omit_self_loops: If True, self-loops (edges where source == target) are excluded\n            attach_node_id_map: If True, adds a 'node_id_map' attribute to the graph\n                containing the mapping from RustWorkX node IDs to original NetworkData node IDs\n\n        Returns:\n            RUSTWORKX_GRAPH_TYPE: RustWorkX graph instance of the specified type\n\n        Note:\n            The original NetworkData '_node_id' values are always included in the\n            node data dictionary, regardless of the incl_node_attributes setting.\n        \"\"\"\n\n        from bidict import bidict\n\n        graph = graph_type(multigraph=multigraph)\n\n        # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n        # include node attributes)\n\n        self._calculate_node_attributes(incl_node_attributes)[1:]\n        self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n        # we can use a 'global' dict here because we know the nodes are processed before the edges\n        node_map: bidict = bidict()\n\n        def add_node(_node_id: int, **attrs):\n            data = {NODE_ID_COLUMN_NAME: _node_id}\n            data.update(attrs)\n\n            graph_node_id = graph.add_node(data)\n\n            node_map[graph_node_id] = _node_id\n            # if not _node_id == graph_node_id:\n            #     raise Exception(\"Internal error: node ids don't match\")\n\n        def add_edge(_source: int, _target: int, **attrs):\n            source = node_map[_source]\n            target = node_map[_target]\n            if not attrs:\n                graph.add_edge(source, target, None)\n            else:\n                graph.add_edge(source, target, attrs)\n\n        self.retrieve_graph_data(\n            nodes_callback=add_node,\n            edges_callback=add_edge,\n            incl_node_attributes=incl_node_attributes,\n            incl_edge_attributes=incl_edge_attributes,\n            omit_self_loops=omit_self_loops,\n        )\n\n        if attach_node_id_map:\n            graph.attrs = {\"node_id_map\": node_map}  # type: ignore\n\n        return graph\n\n    @property\n    def component_ids(self) -&gt; Set[int]:\n        import duckdb\n\n        nodes_table = self.nodes.arrow_table  # noqa\n        query = f\"\"\"\n        SELECT DISTINCT {COMPONENT_ID_COLUMN_NAME} FROM nodes_table\n        \"\"\"\n\n        result: Set[int] = set([x[0] for x in duckdb.sql(query).fetchall()])\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.edges","title":"<code>edges: KiaraTable</code>  <code>property</code>","text":"<p>Access the edges table containing all edge data and computed statistics.</p> <p>The edges table contains both original edge attributes and computed columns: - 'edge_id': Unique edge identifier - '_source', '_target': Node IDs for edge endpoints - '_count_dup': Parallel edge counts for different graph interpretations - 'idx_dup': Indices within parallel edge groups - Original edge attributes (without '_' prefix)</p> <p>Returns:</p> Name Type Description <code>KiaraTable</code> <code>KiaraTable</code> <p>The edges table with full schema and data access methods</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.nodes","title":"<code>nodes: KiaraTable</code>  <code>property</code>","text":"<p>Access the nodes table containing all node data and computed statistics.</p> <p>The nodes table contains both original node attributes and computed columns: - 'node_id': Unique node identifier (sequential integers from 0) - '_label': Human-readable node label - '_count_edges': Edge counts for different graph interpretations - '_in_edges', '_out_edges': Directional edge counts - '_degree_centrality': Normalized degree centrality measures - Original node attributes (without '' prefix)</p> <p>Returns:</p> Name Type Description <code>KiaraTable</code> <code>KiaraTable</code> <p>The nodes table with full schema and data access methods</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.num_nodes","title":"<code>num_nodes: int</code>  <code>property</code>","text":"<p>Get the total number of nodes in the network.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of nodes in the network</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.num_edges","title":"<code>num_edges: int</code>  <code>property</code>","text":"<p>Get the total number of edges in the network.</p> <p>Note: This returns the total number of edge records, which includes all parallel edges in multi-graph interpretations.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Total number of edges (including parallel edges)</p>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.component_ids","title":"<code>component_ids: Set[int]</code>  <code>property</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.create_augmented","title":"<code>create_augmented(network_data: NetworkData, additional_edges_columns: Union[None, Dict[str, pa.Array]] = None, additional_nodes_columns: Union[None, Dict[str, pa.Array]] = None, nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None, edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a new NetworkData instance with additional columns.</p> <p>This method creates a new NetworkData instance by adding extra columns to an existing instance without recomputing the automatically generated internal columns (those prefixed with '_'). This is useful for adding derived attributes or analysis results.</p> <p>Parameters:</p> Name Type Description Default <code>network_data</code> <code>NetworkData</code> <p>The source NetworkData instance to augment</p> required <code>additional_edges_columns</code> <code>Union[None, Dict[str, Array]]</code> <p>Dictionary mapping column names to PyArrow Arrays for new edge attributes</p> <code>None</code> <code>additional_nodes_columns</code> <code>Union[None, Dict[str, Array]]</code> <p>Dictionary mapping column names to PyArrow Arrays for new node attributes</p> <code>None</code> <code>nodes_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to nodes table columns</p> <code>None</code> <code>edges_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to edges table columns</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance with the additional columns</p> Example <pre><code>import pyarrow as pa\n\n# Add a weight column to edges\nweights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\naugmented = NetworkData.create_augmented(\n    network_data,\n    additional_edges_columns={\"weight\": weights}\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_augmented(\n    cls,\n    network_data: \"NetworkData\",\n    additional_edges_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n    additional_nodes_columns: Union[None, Dict[str, \"pa.Array\"]] = None,\n    nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a new NetworkData instance with additional columns.\n\n    This method creates a new NetworkData instance by adding extra columns to an existing\n    instance without recomputing the automatically generated internal columns (those\n    prefixed with '_'). This is useful for adding derived attributes or analysis results.\n\n    Args:\n        network_data: The source NetworkData instance to augment\n        additional_edges_columns: Dictionary mapping column names to PyArrow Arrays\n            for new edge attributes\n        additional_nodes_columns: Dictionary mapping column names to PyArrow Arrays\n            for new node attributes\n        nodes_column_metadata: Additional metadata to attach to nodes table columns\n        edges_column_metadata: Additional metadata to attach to edges table columns\n\n    Returns:\n        NetworkData: A new NetworkData instance with the additional columns\n\n    Example:\n        ```python\n        import pyarrow as pa\n\n        # Add a weight column to edges\n        weights = pa.array([1.0, 2.5, 0.8] * (network_data.num_edges // 3))\n        augmented = NetworkData.create_augmented(\n            network_data,\n            additional_edges_columns={\"weight\": weights}\n        )\n        ```\n    \"\"\"\n\n    nodes_table = network_data.nodes.arrow_table\n    edges_table = network_data.edges.arrow_table\n\n    # nodes_table = pa.Table.from_arrays(orig_nodes_table.columns, schema=orig_nodes_table.schema)\n    # edges_table = pa.Table.from_arrays(orig_edges_table.columns, schema=orig_edges_table.schema)\n\n    if additional_edges_columns is not None:\n        for col_name, col_data in additional_edges_columns.items():\n            edges_table = edges_table.append_column(col_name, col_data)\n\n    if additional_nodes_columns is not None:\n        for col_name, col_data in additional_nodes_columns.items():\n            nodes_table = nodes_table.append_column(col_name, col_data)\n\n    new_network_data = NetworkData.create_network_data(\n        nodes_table=nodes_table,\n        edges_table=edges_table,\n        augment_tables=False,\n        nodes_column_metadata=nodes_column_metadata,\n        edges_column_metadata=edges_column_metadata,\n    )\n\n    return new_network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.create_network_data","title":"<code>create_network_data(nodes_table: pa.Table, edges_table: pa.Table, augment_tables: bool = True, nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None, edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a NetworkData instance from PyArrow tables.</p> <p>This is the primary factory method for creating NetworkData instances from raw tabular data. It supports all graph types and automatically computes necessary metadata for efficient graph operations.</p> <p>Required Table Structure:</p> <p>Nodes table must contain: - '_node_id' (int): Unique integer identifier for each node - '_label' (str): Human-readable label for the node</p> <p>Edges table must contain: - '_source' (int): Source node ID (must exist in nodes table) - '_target' (int): Target node ID (must exist in nodes table)</p> <p>Automatic Augmentation: When <code>augment_tables=True</code> (default), the method automatically adds computed columns:</p> <p>For edges: - '_edge_id': Unique edge identifier - '_count_dup_directed': Count of parallel edges (directed interpretation) - '_idx_dup_directed': Index within parallel edge group (directed) - '_count_dup_undirected': Count of parallel edges (undirected interpretation) - '_idx_dup_undirected': Index within parallel edge group (undirected)</p> <p>For nodes: - '_count_edges': Total edge count (simple graph interpretation) - '_count_edges_multi': Total edge count (multi-graph interpretation) - '_in_edges': Incoming edge count (directed, simple) - '_out_edges': Outgoing edge count (directed, simple) - '_in_edges_multi': Incoming edge count (directed, multi) - '_out_edges_multi': Outgoing edge count (directed, multi) - '_degree_centrality': Normalized degree centrality - '_degree_centrality_multi': Normalized degree centrality (multi-graph)</p> <p>Parameters:</p> Name Type Description Default <code>nodes_table</code> <code>Table</code> <p>PyArrow table containing node data</p> required <code>edges_table</code> <code>Table</code> <p>PyArrow table containing edge data</p> required <code>augment_tables</code> <code>bool</code> <p>Whether to compute and add internal metadata columns. Set to False only if you know the metadata is already present and correct.</p> <code>True</code> <code>nodes_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to nodes table columns. Format: {column_name: {property_name: property_value}}</p> <code>None</code> <code>edges_column_metadata</code> <code>Union[Dict[str, Dict[str, KiaraModel]], None]</code> <p>Additional metadata to attach to edges table columns. Format: {column_name: {property_name: property_value}}</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance</p> <p>Raises:</p> Type Description <code>KiaraException</code> <p>If required columns are missing or contain null values</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_network_data(\n    cls,\n    nodes_table: \"pa.Table\",\n    edges_table: \"pa.Table\",\n    augment_tables: bool = True,\n    nodes_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n    edges_column_metadata: Union[Dict[str, Dict[str, KiaraModel]], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a NetworkData instance from PyArrow tables.\n\n    This is the primary factory method for creating NetworkData instances from raw tabular data.\n    It supports all graph types and automatically computes necessary metadata for efficient\n    graph operations.\n\n    **Required Table Structure:**\n\n    Nodes table must contain:\n    - '_node_id' (int): Unique integer identifier for each node\n    - '_label' (str): Human-readable label for the node\n\n    Edges table must contain:\n    - '_source' (int): Source node ID (must exist in nodes table)\n    - '_target' (int): Target node ID (must exist in nodes table)\n\n    **Automatic Augmentation:**\n    When `augment_tables=True` (default), the method automatically adds computed columns:\n\n    For edges:\n    - '_edge_id': Unique edge identifier\n    - '_count_dup_directed': Count of parallel edges (directed interpretation)\n    - '_idx_dup_directed': Index within parallel edge group (directed)\n    - '_count_dup_undirected': Count of parallel edges (undirected interpretation)\n    - '_idx_dup_undirected': Index within parallel edge group (undirected)\n\n    For nodes:\n    - '_count_edges': Total edge count (simple graph interpretation)\n    - '_count_edges_multi': Total edge count (multi-graph interpretation)\n    - '_in_edges': Incoming edge count (directed, simple)\n    - '_out_edges': Outgoing edge count (directed, simple)\n    - '_in_edges_multi': Incoming edge count (directed, multi)\n    - '_out_edges_multi': Outgoing edge count (directed, multi)\n    - '_degree_centrality': Normalized degree centrality\n    - '_degree_centrality_multi': Normalized degree centrality (multi-graph)\n\n    Args:\n        nodes_table: PyArrow table containing node data\n        edges_table: PyArrow table containing edge data\n        augment_tables: Whether to compute and add internal metadata columns.\n            Set to False only if you know the metadata is already present and correct.\n        nodes_column_metadata: Additional metadata to attach to nodes table columns.\n            Format: {column_name: {property_name: property_value}}\n        edges_column_metadata: Additional metadata to attach to edges table columns.\n            Format: {column_name: {property_name: property_value}}\n\n    Returns:\n        NetworkData: A new NetworkData instance\n\n    Raises:\n        KiaraException: If required columns are missing or contain null values\n\n    \"\"\"\n\n    from kiara_plugin.network_analysis.models.metadata import (\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_ID_COLUMN_METADATA,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        EDGE_SOURCE_COLUMN_METADATA,\n        EDGE_TARGET_COLUMN_METADATA,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        NODE_DEGREE_COLUMN_METADATA,\n        NODE_DEGREE_MULTI_COLUMN_METADATA,\n        NODE_ID_COLUMN_METADATA,\n        NODE_LABEL_COLUMN_METADATA,\n    )\n\n    if augment_tables:\n        edges_table = augment_edges_table_with_id_and_weights(edges_table)\n        nodes_table = augment_nodes_table_with_connection_counts(\n            nodes_table, edges_table\n        )\n        nodes_table, edges_table = augment_tables_with_component_ids(\n            nodes_table=nodes_table, edges_table=edges_table\n        )\n\n    if edges_table.column(SOURCE_COLUMN_NAME).null_count &gt; 0:\n        raise KiaraException(\n            msg=\"Can't assemble network data.\",\n            details=\"Source column in edges table contains null values.\",\n        )\n    if edges_table.column(TARGET_COLUMN_NAME).null_count &gt; 0:\n        raise KiaraException(\n            msg=\"Can't assemble network data.\",\n            details=\"Target column in edges table contains null values.\",\n        )\n\n    network_data: NetworkData = cls.create_tables(\n        {NODES_TABLE_NAME: nodes_table, EDGES_TABLE_NAME: edges_table}\n    )\n\n    # set default column metadata\n    network_data.edges.set_column_metadata(\n        EDGE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        SOURCE_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_SOURCE_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        TARGET_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_TARGET_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.edges.set_column_metadata(\n        COUNT_IDX_UNDIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    network_data.nodes.set_column_metadata(\n        NODE_ID_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_ID_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        LABEL_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_LABEL_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_DEGREE_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        CONNECTIONS_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUND_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_DEGREE_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        IN_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n    network_data.nodes.set_column_metadata(\n        OUT_DIRECTED_MULTI_COLUMN_NAME,\n        ATTRIBUTE_PROPERTY_KEY,\n        NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA,\n        overwrite_existing=False,\n    )\n\n    if nodes_column_metadata is not None:\n        for col_name, col_meta in nodes_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.nodes.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n    if edges_column_metadata is not None:\n        for col_name, col_meta in edges_column_metadata.items():\n            for prop_name, prop_value in col_meta.items():\n                network_data.edges.set_column_metadata(\n                    col_name, prop_name, prop_value, overwrite_existing=True\n                )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.from_filtered_nodes","title":"<code>from_filtered_nodes(network_data: NetworkData, nodes_list: List[int]) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a new, filtered instance of this class using a source network, and a list of node ids to include.</p> <p>Nodes/edges containing a node id not in the list will be removed from the resulting network data.</p> <p>Parameters:</p> Name Type Description Default <code>network_data</code> <code>NetworkData</code> <p>the source network data</p> required <code>nodes_list</code> <code>List[int]</code> <p>the list of node ids to include in the filtered network data</p> required Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef from_filtered_nodes(\n    cls, network_data: \"NetworkData\", nodes_list: List[int]\n) -&gt; \"NetworkData\":\n    \"\"\"Create a new, filtered instance of this class using a source network, and a list of node ids to include.\n\n    Nodes/edges containing a node id not in the list will be removed from the resulting network data.\n\n    Arguments:\n        network_data: the source network data\n        nodes_list: the list of node ids to include in the filtered network data\n    \"\"\"\n\n    import duckdb\n    import polars as pl\n\n    node_columns = [NODE_ID_COLUMN_NAME, LABEL_COLUMN_NAME]\n    for column_name, metadata in network_data.nodes.column_metadata.items():\n        attr_prop: Union[None, NetworkNodeAttributeMetadata] = metadata.get(  # type: ignore\n            ATTRIBUTE_PROPERTY_KEY, None\n        )\n        if attr_prop is None or not attr_prop.computed_attribute:\n            node_columns.append(column_name)\n\n    node_list_str = \", \".join([str(n) for n in nodes_list])\n\n    nodes_table = network_data.nodes.arrow_table  # noqa\n    nodes_query = f\"SELECT {', '.join(node_columns)} FROM nodes_table n WHERE n.{NODE_ID_COLUMN_NAME} IN ({node_list_str})\"\n\n    nodes_result = duckdb.sql(nodes_query).pl()\n\n    edges_table = network_data.edges.arrow_table  # noqa\n    edge_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n    for column_name, metadata in network_data.edges.column_metadata.items():\n        attr_prop = metadata.get(ATTRIBUTE_PROPERTY_KEY, None)  # type: ignore\n        if attr_prop is None or not attr_prop.computed_attribute:\n            edge_columns.append(column_name)\n\n    edges_query = f\"SELECT {', '.join(edge_columns)} FROM edges_table WHERE {SOURCE_COLUMN_NAME} IN ({node_list_str}) OR {TARGET_COLUMN_NAME} IN ({node_list_str})\"\n\n    edges_result = duckdb.sql(edges_query).pl()\n\n    nodes_idx_colum = range(len(nodes_result))\n    old_idx_column = nodes_result[NODE_ID_COLUMN_NAME]\n\n    repl_map = dict(zip(old_idx_column.to_list(), nodes_idx_colum))\n    nodes_result = nodes_result.with_columns(\n        pl.col(NODE_ID_COLUMN_NAME).replace_strict(repl_map, default=None)\n    )\n\n    edges_result = edges_result.with_columns(\n        pl.col(SOURCE_COLUMN_NAME).replace_strict(repl_map, default=None),\n        pl.col(TARGET_COLUMN_NAME).replace_strict(repl_map, default=None),\n    )\n\n    filtered = NetworkData.create_network_data(\n        nodes_table=nodes_result, edges_table=edges_result\n    )\n    return filtered\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.create_from_networkx_graph","title":"<code>create_from_networkx_graph(graph: nx.Graph, label_attr_name: Union[str, None] = None, ignore_node_attributes: Union[Iterable[str], None] = None) -&gt; NetworkData</code>  <code>classmethod</code>","text":"<p>Create a NetworkData instance from any NetworkX graph type.</p> <p>This method provides seamless conversion from NetworkX graphs to NetworkData, preserving all node and edge attributes while automatically handling different graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).</p> <p>Graph Type Support: - nx.Graph: Converted to undirected simple graph representation - nx.DiGraph: Converted to directed simple graph representation - nx.MultiGraph: Converted with multi-edge support (undirected) - nx.MultiDiGraph: Converted with multi-edge support (directed)</p> <p>Attribute Handling: All NetworkX node and edge attributes are preserved as columns in the resulting tables, except those starting with '_' (reserved for internal use).</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)</p> required <code>label_attr_name</code> <code>Union[str, None]</code> <p>Name of the node attribute to use as the node label. If None, the node ID is converted to string and used as label. Can also be an iterable of attribute names to try in order.</p> <code>None</code> <code>ignore_node_attributes</code> <code>Union[Iterable[str], None]</code> <p>List of node attribute names to exclude from the resulting nodes table</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NetworkData</code> <code>NetworkData</code> <p>A new NetworkData instance representing the graph</p> <p>Raises:</p> Type Description <code>KiaraException</code> <p>If node/edge attributes contain names starting with '_'</p> Note <p>Node IDs in the original NetworkX graph are mapped to sequential integers starting from 0 in the NetworkData representation. The original node IDs are preserved as the '_label' if no label_attr_name is specified.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_from_networkx_graph(\n    cls,\n    graph: \"nx.Graph\",\n    label_attr_name: Union[str, None] = None,\n    ignore_node_attributes: Union[Iterable[str], None] = None,\n) -&gt; \"NetworkData\":\n    \"\"\"Create a NetworkData instance from any NetworkX graph type.\n\n    This method provides seamless conversion from NetworkX graphs to NetworkData,\n    preserving all node and edge attributes while automatically handling different\n    graph types (Graph, DiGraph, MultiGraph, MultiDiGraph).\n\n    **Graph Type Support:**\n    - **nx.Graph**: Converted to undirected simple graph representation\n    - **nx.DiGraph**: Converted to directed simple graph representation\n    - **nx.MultiGraph**: Converted with multi-edge support (undirected)\n    - **nx.MultiDiGraph**: Converted with multi-edge support (directed)\n\n    **Attribute Handling:**\n    All NetworkX node and edge attributes are preserved as columns in the resulting\n    tables, except those starting with '_' (reserved for internal use).\n\n    Args:\n        graph: Any NetworkX graph instance (Graph, DiGraph, MultiGraph, MultiDiGraph)\n        label_attr_name: Name of the node attribute to use as the node label.\n            If None, the node ID is converted to string and used as label.\n            Can also be an iterable of attribute names to try in order.\n        ignore_node_attributes: List of node attribute names to exclude from\n            the resulting nodes table\n\n    Returns:\n        NetworkData: A new NetworkData instance representing the graph\n\n    Raises:\n        KiaraException: If node/edge attributes contain names starting with '_'\n\n    Note:\n        Node IDs in the original NetworkX graph are mapped to sequential integers\n        starting from 0 in the NetworkData representation. The original node IDs\n        are preserved as the '_label' if no label_attr_name is specified.\n    \"\"\"\n\n    # TODO: should we also index nodes/edges attributes?\n\n    nodes_table, node_id_map = extract_networkx_nodes_as_table(\n        graph=graph,\n        label_attr_name=label_attr_name,\n        ignore_attributes=ignore_node_attributes,\n    )\n\n    edges_table = extract_networkx_edges_as_table(graph, node_id_map)\n\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes_table, edges_table=edges_table\n    )\n\n    return network_data\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.query_edges","title":"<code>query_edges(sql_query: str, relation_name: str = EDGES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Execute SQL queries on the edges table for flexible data analysis.</p> <p>This method provides direct SQL access to the edges table, enabling complex queries and aggregations. All computed edge columns are available for querying.</p> <p>Available Columns: - 'edge_id': Unique edge identifier - '_source', '_target': Node IDs for edge endpoints - '_count_dup_directed': Number of parallel edges (directed interpretation) - '_idx_dup_directed': Index within parallel edge group (directed) - '_count_dup_undirected': Number of parallel edges (undirected interpretation) - '_idx_dup_undirected': Index within parallel edge group (undirected) - Original edge attributes (names without '' prefix)</p> <p>Parameters:</p> Name Type Description Default <code>sql_query</code> <code>str</code> <p>SQL query string. Use 'edges' as the table name in your query.</p> required <code>relation_name</code> <code>str</code> <p>Alternative table name to use in the query (default: 'edges'). If specified, all occurrences of this name in the query will be replaced with 'edges'.</p> <code>EDGES_TABLE_NAME</code> <p>Returns:</p> Type Description <code>Table</code> <p>pa.Table: Query results as a PyArrow table</p> Example <pre><code># Find edges with high multiplicity\nparallel_edges = network_data.query_edges(\n    \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n)\n\n# Get edge statistics\nstats = network_data.query_edges(\n    \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_edges(\n    self, sql_query: str, relation_name: str = EDGES_TABLE_NAME\n) -&gt; \"pa.Table\":\n    \"\"\"Execute SQL queries on the edges table for flexible data analysis.\n\n    This method provides direct SQL access to the edges table, enabling complex\n    queries and aggregations. All computed edge columns are available for querying.\n\n    **Available Columns:**\n    - '_edge_id': Unique edge identifier\n    - '_source', '_target': Node IDs for edge endpoints\n    - '_count_dup_directed': Number of parallel edges (directed interpretation)\n    - '_idx_dup_directed': Index within parallel edge group (directed)\n    - '_count_dup_undirected': Number of parallel edges (undirected interpretation)\n    - '_idx_dup_undirected': Index within parallel edge group (undirected)\n    - Original edge attributes (names without '_' prefix)\n\n    Args:\n        sql_query: SQL query string. Use 'edges' as the table name in your query.\n        relation_name: Alternative table name to use in the query (default: 'edges').\n            If specified, all occurrences of this name in the query will be replaced\n            with 'edges'.\n\n    Returns:\n        pa.Table: Query results as a PyArrow table\n\n    Example:\n        ```python\n        # Find edges with high multiplicity\n        parallel_edges = network_data.query_edges(\n            \"SELECT _source, _target, _count_dup_directed FROM edges WHERE _count_dup_directed &gt; 1\"\n        )\n\n        # Get edge statistics\n        stats = network_data.query_edges(\n            \"SELECT COUNT(*) as total_edges, AVG(_count_dup_directed) as avg_multiplicity FROM edges\"\n        )\n        ```\n    \"\"\"\n    import duckdb\n\n    con = duckdb.connect()\n    edges = self.edges.arrow_table  # noqa: F841\n    if relation_name != EDGES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, EDGES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.query_nodes","title":"<code>query_nodes(sql_query: str, relation_name: str = NODES_TABLE_NAME) -&gt; pa.Table</code>","text":"<p>Execute SQL queries on the nodes table for flexible data analysis.</p> <p>This method provides direct SQL access to the nodes table, enabling complex queries and aggregations. All computed node statistics are available for querying.</p> <p>Available Columns: - 'node_id': Unique node identifier - '_label': Human-readable node label - '_count_edges': Total edge count (simple graph interpretation) - '_count_edges_multi': Total edge count (multi-graph interpretation) - '_in_edges': Incoming edge count (directed, simple) - '_out_edges': Outgoing edge count (directed, simple) - '_in_edges_multi': Incoming edge count (directed, multi) - '_out_edges_multi': Outgoing edge count (directed, multi) - '_degree_centrality': Normalized degree centrality (simple) - '_degree_centrality_multi': Normalized degree centrality (multi) - Original node attributes (names without '' prefix)</p> <p>Parameters:</p> Name Type Description Default <code>sql_query</code> <code>str</code> <p>SQL query string. Use 'nodes' as the table name in your query.</p> required <code>relation_name</code> <code>str</code> <p>Alternative table name to use in the query (default: 'nodes'). If specified, all occurrences of this name in the query will be replaced with 'nodes'.</p> <code>NODES_TABLE_NAME</code> <p>Returns:</p> Type Description <code>Table</code> <p>pa.Table: Query results as a PyArrow table</p> Example <pre><code># Find high-degree nodes\nhubs = network_data.query_nodes(\n    \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n)\n\n# Get centrality statistics\ncentrality_stats = network_data.query_nodes(\n    \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n)\n</code></pre> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def query_nodes(\n    self, sql_query: str, relation_name: str = NODES_TABLE_NAME\n) -&gt; \"pa.Table\":\n    \"\"\"Execute SQL queries on the nodes table for flexible data analysis.\n\n    This method provides direct SQL access to the nodes table, enabling complex\n    queries and aggregations. All computed node statistics are available for querying.\n\n    **Available Columns:**\n    - '_node_id': Unique node identifier\n    - '_label': Human-readable node label\n    - '_count_edges': Total edge count (simple graph interpretation)\n    - '_count_edges_multi': Total edge count (multi-graph interpretation)\n    - '_in_edges': Incoming edge count (directed, simple)\n    - '_out_edges': Outgoing edge count (directed, simple)\n    - '_in_edges_multi': Incoming edge count (directed, multi)\n    - '_out_edges_multi': Outgoing edge count (directed, multi)\n    - '_degree_centrality': Normalized degree centrality (simple)\n    - '_degree_centrality_multi': Normalized degree centrality (multi)\n    - Original node attributes (names without '_' prefix)\n\n    Args:\n        sql_query: SQL query string. Use 'nodes' as the table name in your query.\n        relation_name: Alternative table name to use in the query (default: 'nodes').\n            If specified, all occurrences of this name in the query will be replaced\n            with 'nodes'.\n\n    Returns:\n        pa.Table: Query results as a PyArrow table\n\n    Example:\n        ```python\n        # Find high-degree nodes\n        hubs = network_data.query_nodes(\n            \"SELECT _node_id, _label, _count_edges FROM nodes WHERE _count_edges &gt; 10 ORDER BY _count_edges DESC\"\n        )\n\n        # Get centrality statistics\n        centrality_stats = network_data.query_nodes(\n            \"SELECT AVG(_degree_centrality) as avg_centrality, MAX(_degree_centrality) as max_centrality FROM nodes\"\n        )\n        ```\n    \"\"\"\n    import duckdb\n\n    con = duckdb.connect()\n    nodes = self.nodes.arrow_table  # noqa\n    if relation_name != NODES_TABLE_NAME:\n        sql_query = sql_query.replace(relation_name, NODES_TABLE_NAME)\n\n    result = con.execute(sql_query)\n    return result.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.retrieve_graph_data","title":"<code>retrieve_graph_data(nodes_callback: Union[NodesCallback, None] = None, edges_callback: Union[EdgesCallback, None] = None, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False)</code>","text":"<p>Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.</p> <p>First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.</p> The nodes_callback will be called with the following arguments <ul> <li>node_id: the id of the node (int)</li> <li>if False: nothing else</li> <li>if True: all node attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified node attribute</li> <li>if Iterable[str]: the values of the specified node attributes, in the order they are specified</li> </ul> The edges_callback will be called with the following aruments <ul> <li>source_id: the id of the source node (int)</li> <li>target_id: the id of the target node (int)</li> <li>if False: nothing else</li> <li>if True: all edge attributes, in the order they are defined in the table schema</li> <li>if str: the value of the specified edge attribute</li> <li>if Iterable[str]: the values of the specified edge attributes, in the order they are specified</li> </ul> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def retrieve_graph_data(\n    self,\n    nodes_callback: Union[NodesCallback, None] = None,\n    edges_callback: Union[EdgesCallback, None] = None,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n):\n    \"\"\"Retrieve graph data from the sqlite database, and call the specified callbacks for each node and edge.\n\n    First the nodes will be processed, then the edges, if that does not suit your needs you can just use this method twice, and set the callback you don't need to None.\n\n    The nodes_callback will be called with the following arguments:\n        - node_id: the id of the node (int)\n        - if False: nothing else\n        - if True: all node attributes, in the order they are defined in the table schema\n        - if str: the value of the specified node attribute\n        - if Iterable[str]: the values of the specified node attributes, in the order they are specified\n\n    The edges_callback will be called with the following aruments:\n        - source_id: the id of the source node (int)\n        - target_id: the id of the target node (int)\n        - if False: nothing else\n        - if True: all edge attributes, in the order they are defined in the table schema\n        - if str: the value of the specified edge attribute\n        - if Iterable[str]: the values of the specified edge attributes, in the order they are specified\n\n    \"\"\"\n\n    if nodes_callback is not None:\n        node_attr_names = self._calculate_node_attributes(incl_node_attributes)\n\n        nodes_df = self.nodes.to_polars_dataframe()\n        for row in nodes_df.select(*node_attr_names).rows(named=True):\n            nodes_callback(**row)  # type: ignore\n\n    if edges_callback is not None:\n        edge_attr_names = self._calculate_edge_attributes(incl_edge_attributes)\n\n        edges_df = self.edges.to_polars_dataframe()\n        for row in edges_df.select(*edge_attr_names).rows(named=True):\n            if (\n                omit_self_loops\n                and row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]\n            ):\n                continue\n            edges_callback(**row)  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.as_networkx_graph","title":"<code>as_networkx_graph(graph_type: Type[NETWORKX_GRAPH_TYPE], incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False) -&gt; NETWORKX_GRAPH_TYPE</code>","text":"<p>Export the network data as a NetworkX graph object.</p> <p>This method converts the NetworkData to any NetworkX graph type, providing flexibility to work with the data using NetworkX's extensive algorithm library. The conversion preserves node and edge attributes as specified.</p> <p>Supported Graph Types: - nx.Graph: Undirected simple graph (parallel edges are merged) - nx.DiGraph: Directed simple graph (parallel edges are merged) - nx.MultiGraph: Undirected multigraph (parallel edges preserved) - nx.MultiDiGraph: Directed multigraph (parallel edges preserved)</p> <p>Attribute Handling: Node and edge attributes can be selectively included in the exported graph. Internal columns (prefixed with '_') are available but typically excluded from exports to maintain clean NetworkX compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[NETWORKX_GRAPH_TYPE]</code> <p>NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)</p> required <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which node attributes to include: - False: No attributes (only node IDs) - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which edge attributes to include: - False: No attributes - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>If True, edges where source equals target are excluded</p> <code>False</code> <p>Returns:</p> Name Type Description <code>NETWORKX_GRAPH_TYPE</code> <code>NETWORKX_GRAPH_TYPE</code> <p>NetworkX graph instance of the specified type</p> Note <p>When exporting to simple graph types (Graph, DiGraph), parallel edges are automatically merged. Use MultiGraph or MultiDiGraph to preserve all edge instances.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_networkx_graph(\n    self,\n    graph_type: Type[NETWORKX_GRAPH_TYPE],\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n) -&gt; NETWORKX_GRAPH_TYPE:\n    \"\"\"Export the network data as a NetworkX graph object.\n\n    This method converts the NetworkData to any NetworkX graph type, providing\n    flexibility to work with the data using NetworkX's extensive algorithm library.\n    The conversion preserves node and edge attributes as specified.\n\n    **Supported Graph Types:**\n    - **nx.Graph**: Undirected simple graph (parallel edges are merged)\n    - **nx.DiGraph**: Directed simple graph (parallel edges are merged)\n    - **nx.MultiGraph**: Undirected multigraph (parallel edges preserved)\n    - **nx.MultiDiGraph**: Directed multigraph (parallel edges preserved)\n\n    **Attribute Handling:**\n    Node and edge attributes can be selectively included in the exported graph.\n    Internal columns (prefixed with '_') are available but typically excluded\n    from exports to maintain clean NetworkX compatibility.\n\n    Args:\n        graph_type: NetworkX graph class to instantiate (nx.Graph, nx.DiGraph, etc.)\n        incl_node_attributes: Controls which node attributes to include:\n            - False: No attributes (only node IDs)\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        incl_edge_attributes: Controls which edge attributes to include:\n            - False: No attributes\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        omit_self_loops: If True, edges where source equals target are excluded\n\n    Returns:\n        NETWORKX_GRAPH_TYPE: NetworkX graph instance of the specified type\n\n    Note:\n        When exporting to simple graph types (Graph, DiGraph), parallel edges\n        are automatically merged. Use MultiGraph or MultiDiGraph to preserve\n        all edge instances.\n    \"\"\"\n\n    graph: NETWORKX_GRAPH_TYPE = graph_type()\n\n    def add_node(_node_id: int, **attrs):\n        graph.add_node(_node_id, **attrs)\n\n    def add_edge(_source: int, _target: int, **attrs):\n        graph.add_edge(_source, _target, **attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkData.as_rustworkx_graph","title":"<code>as_rustworkx_graph(graph_type: Type[RUSTWORKX_GRAPH_TYPE], multigraph: bool = False, incl_node_attributes: Union[bool, str, Iterable[str]] = False, incl_edge_attributes: Union[bool, str, Iterable[str]] = False, omit_self_loops: bool = False, attach_node_id_map: bool = False) -&gt; RUSTWORKX_GRAPH_TYPE</code>","text":"<p>Export the network data as a RustWorkX graph object.</p> <p>RustWorkX provides high-performance graph algorithms implemented in Rust with Python bindings. This method converts NetworkData to RustWorkX format while handling the differences in node ID management between the two systems.</p> <p>Supported Graph Types: - rx.PyGraph: Undirected graph (with optional multigraph support) - rx.PyDiGraph: Directed graph (with optional multigraph support)</p> <p>Node ID Mapping: RustWorkX uses sequential integer node IDs starting from 0, which may differ from the original NetworkData node IDs. The original '_node_id' values are preserved as node attributes, and an optional mapping can be attached to the graph for reference.</p> <p>Performance Benefits: RustWorkX graphs offer significant performance advantages for: - Large-scale graph algorithms - Parallel processing - Memory-efficient operations - High-performance centrality calculations</p> <p>Parameters:</p> Name Type Description Default <code>graph_type</code> <code>Type[RUSTWORKX_GRAPH_TYPE]</code> <p>RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)</p> required <code>multigraph</code> <code>bool</code> <p>If True, parallel edges are preserved; if False, they are merged</p> <code>False</code> <code>incl_node_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which node attributes to include: - False: No attributes (only node data structure) - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>incl_edge_attributes</code> <code>Union[bool, str, Iterable[str]]</code> <p>Controls which edge attributes to include: - False: No attributes - True: All attributes (including computed columns) - str: Single attribute name to include - Iterable[str]: List of specific attributes to include</p> <code>False</code> <code>omit_self_loops</code> <code>bool</code> <p>If True, self-loops (edges where source == target) are excluded</p> <code>False</code> <code>attach_node_id_map</code> <code>bool</code> <p>If True, adds a 'node_id_map' attribute to the graph containing the mapping from RustWorkX node IDs to original NetworkData node IDs</p> <code>False</code> <p>Returns:</p> Name Type Description <code>RUSTWORKX_GRAPH_TYPE</code> <code>RUSTWORKX_GRAPH_TYPE</code> <p>RustWorkX graph instance of the specified type</p> Note <p>The original NetworkData '_node_id' values are always included in the node data dictionary, regardless of the incl_node_attributes setting.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>def as_rustworkx_graph(\n    self,\n    graph_type: Type[RUSTWORKX_GRAPH_TYPE],\n    multigraph: bool = False,\n    incl_node_attributes: Union[bool, str, Iterable[str]] = False,\n    incl_edge_attributes: Union[bool, str, Iterable[str]] = False,\n    omit_self_loops: bool = False,\n    attach_node_id_map: bool = False,\n) -&gt; RUSTWORKX_GRAPH_TYPE:\n    \"\"\"Export the network data as a RustWorkX graph object.\n\n    RustWorkX provides high-performance graph algorithms implemented in Rust with\n    Python bindings. This method converts NetworkData to RustWorkX format while\n    handling the differences in node ID management between the two systems.\n\n    **Supported Graph Types:**\n    - **rx.PyGraph**: Undirected graph (with optional multigraph support)\n    - **rx.PyDiGraph**: Directed graph (with optional multigraph support)\n\n    **Node ID Mapping:**\n    RustWorkX uses sequential integer node IDs starting from 0, which may differ\n    from the original NetworkData node IDs. The original '_node_id' values are\n    preserved as node attributes, and an optional mapping can be attached to\n    the graph for reference.\n\n    **Performance Benefits:**\n    RustWorkX graphs offer significant performance advantages for:\n    - Large-scale graph algorithms\n    - Parallel processing\n    - Memory-efficient operations\n    - High-performance centrality calculations\n\n    Args:\n        graph_type: RustWorkX graph class (rx.PyGraph or rx.PyDiGraph)\n        multigraph: If True, parallel edges are preserved; if False, they are merged\n        incl_node_attributes: Controls which node attributes to include:\n            - False: No attributes (only node data structure)\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        incl_edge_attributes: Controls which edge attributes to include:\n            - False: No attributes\n            - True: All attributes (including computed columns)\n            - str: Single attribute name to include\n            - Iterable[str]: List of specific attributes to include\n        omit_self_loops: If True, self-loops (edges where source == target) are excluded\n        attach_node_id_map: If True, adds a 'node_id_map' attribute to the graph\n            containing the mapping from RustWorkX node IDs to original NetworkData node IDs\n\n    Returns:\n        RUSTWORKX_GRAPH_TYPE: RustWorkX graph instance of the specified type\n\n    Note:\n        The original NetworkData '_node_id' values are always included in the\n        node data dictionary, regardless of the incl_node_attributes setting.\n    \"\"\"\n\n    from bidict import bidict\n\n    graph = graph_type(multigraph=multigraph)\n\n    # rustworkx uses 0-based integer indexes, so we don't neeed to look up the node ids (unless we want to\n    # include node attributes)\n\n    self._calculate_node_attributes(incl_node_attributes)[1:]\n    self._calculate_edge_attributes(incl_edge_attributes)[2:]\n\n    # we can use a 'global' dict here because we know the nodes are processed before the edges\n    node_map: bidict = bidict()\n\n    def add_node(_node_id: int, **attrs):\n        data = {NODE_ID_COLUMN_NAME: _node_id}\n        data.update(attrs)\n\n        graph_node_id = graph.add_node(data)\n\n        node_map[graph_node_id] = _node_id\n        # if not _node_id == graph_node_id:\n        #     raise Exception(\"Internal error: node ids don't match\")\n\n    def add_edge(_source: int, _target: int, **attrs):\n        source = node_map[_source]\n        target = node_map[_target]\n        if not attrs:\n            graph.add_edge(source, target, None)\n        else:\n            graph.add_edge(source, target, attrs)\n\n    self.retrieve_graph_data(\n        nodes_callback=add_node,\n        edges_callback=add_edge,\n        incl_node_attributes=incl_node_attributes,\n        incl_edge_attributes=incl_edge_attributes,\n        omit_self_loops=omit_self_loops,\n    )\n\n    if attach_node_id_map:\n        graph.attrs = {\"node_id_map\": node_map}  # type: ignore\n\n    return graph\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties","title":"<code>GraphProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Properties of graph data, if interpreted as a specific graph type.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class GraphProperties(BaseModel):\n    \"\"\"Properties of graph data, if interpreted as a specific graph type.\"\"\"\n\n    number_of_edges: int = Field(description=\"The number of edges.\")\n    parallel_edges: int = Field(\n        description=\"The number of parallel edges (if 'multi' graph type).\", default=0\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties.number_of_edges","title":"<code>number_of_edges: int = Field(description='The number of edges.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.GraphProperties.parallel_edges","title":"<code>parallel_edges: int = Field(description=\"The number of parallel edges (if 'multi' graph type).\", default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.ComponentProperties","title":"<code>ComponentProperties</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Properties of a connected component.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class ComponentProperties(BaseModel):\n    \"\"\"Properties of a connected component.\"\"\"\n\n    component_id: int = Field(description=\"The id of the component.\")\n    number_of_nodes: int = Field(description=\"The number of nodes in the component.\")\n    number_of_associated_edge_rows: int = Field(\n        description=\"The number of edge rows associated to the component.\"\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.ComponentProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.ComponentProperties.component_id","title":"<code>component_id: int = Field(description='The id of the component.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.ComponentProperties.number_of_nodes","title":"<code>number_of_nodes: int = Field(description='The number of nodes in the component.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.ComponentProperties.number_of_associated_edge_rows","title":"<code>number_of_associated_edge_rows: int = Field(description='The number of edge rows associated to the component.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties","title":"<code>NetworkGraphProperties</code>","text":"<p>               Bases: <code>ValueMetadata</code></p> <p>Network data stats.</p> Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>class NetworkGraphProperties(ValueMetadata):\n    \"\"\"Network data stats.\"\"\"\n\n    _metadata_key: ClassVar[str] = \"network_data\"\n\n    number_of_nodes: int = Field(description=\"Number of nodes in the network graph.\")\n    properties_by_graph_type: Dict[  # type: ignore\n        Literal[\n            GraphType.DIRECTED.value,\n            GraphType.UNDIRECTED.value,\n            GraphType.UNDIRECTED_MULTI.value,\n            GraphType.DIRECTED_MULTI.value,\n        ],\n        GraphProperties,\n    ] = Field(description=\"Properties of the network data, by graph type.\")\n    number_of_self_loops: int = Field(\n        description=\"Number of edges where source and target point to the same node.\"\n    )\n    number_of_components: int = Field(\n        description=\"Number of connected components in the network graph.\"\n    )\n    components: Dict[int, ComponentProperties] = Field(\n        description=\"Properties of the components of the network graph.\"\n    )\n\n    @classmethod\n    def retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n        return [\"network_data\"]\n\n    @classmethod\n    def create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n        import duckdb\n\n        network_data: NetworkData = value.data\n\n        num_rows = network_data.num_nodes\n        num_edges = network_data.num_edges\n\n        # query_num_edges_directed = f\"SELECT COUNT(*) FROM (SELECT DISTINCT {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME} FROM {EDGES_TABLE_NAME})\"\n        query_num_edges_directed = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\"\n\n        num_edges_directed_result = network_data.query_edges(query_num_edges_directed)\n        num_edges_directed = num_edges_directed_result.columns[0][0].as_py()\n\n        query_num_edges_undirected = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 1\"\n        num_edges_undirected_result = network_data.query_edges(\n            query_num_edges_undirected\n        )\n        num_edges_undirected = num_edges_undirected_result.columns[0][0].as_py()\n\n        self_loop_query = f\"SELECT count(*) FROM {EDGES_TABLE_NAME} WHERE {SOURCE_COLUMN_NAME} = {TARGET_COLUMN_NAME}\"\n        self_loop_result = network_data.query_edges(self_loop_query)\n        num_self_loops = self_loop_result.columns[0][0].as_py()\n\n        num_parallel_edges_directed_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 2\"\n        num_parallel_edges_directed_result = network_data.query_edges(\n            num_parallel_edges_directed_query\n        )\n        num_parallel_edges_directed = num_parallel_edges_directed_result.columns[0][\n            0\n        ].as_py()\n\n        num_parallel_edges_undirected_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 2\"\n        num_parallel_edges_undirected_result = network_data.query_edges(\n            num_parallel_edges_undirected_query\n        )\n        num_parallel_edges_undirected = num_parallel_edges_undirected_result.columns[0][\n            0\n        ].as_py()\n\n        directed_props = GraphProperties(number_of_edges=num_edges_directed)\n        undirected_props = GraphProperties(number_of_edges=num_edges_undirected)\n        directed_multi_props = GraphProperties(\n            number_of_edges=num_edges, parallel_edges=num_parallel_edges_directed\n        )\n        undirected_multi_props = GraphProperties(\n            number_of_edges=num_edges, parallel_edges=num_parallel_edges_undirected\n        )\n\n        props = {\n            GraphType.DIRECTED.value: directed_props,\n            GraphType.DIRECTED_MULTI.value: directed_multi_props,\n            GraphType.UNDIRECTED.value: undirected_props,\n            GraphType.UNDIRECTED_MULTI.value: undirected_multi_props,\n        }\n\n        nodes_table = network_data.nodes.arrow_table  # noqa\n        edges_table = network_data.edges.arrow_table  # noqa\n\n        components_query_nodes = f\"\"\"\n            SELECT\n                {COMPONENT_ID_COLUMN_NAME}, COUNT(*)\n            FROM\n                nodes_table\n            GROUP BY {COMPONENT_ID_COLUMN_NAME}\n        \"\"\"\n        nodes_result = duckdb.query(components_query_nodes)\n        nodes_data = nodes_result.fetchall()\n        nodes_data_dict = {row[0]: row[1] for row in nodes_data}\n\n        components_query_edges = f\"\"\"\n            SELECT\n                {COMPONENT_ID_COLUMN_NAME}, COUNT(*)\n            FROM\n                edges_table\n            GROUP BY {COMPONENT_ID_COLUMN_NAME}\n        \"\"\"\n        edges_result = duckdb.query(components_query_edges)\n        edges_data = edges_result.fetchall()\n        edges_data_dict = {row[0]: row[1] for row in edges_data}\n\n        components_data = {}\n        for component_id, num_nodes in nodes_data_dict.items():\n            num_edges = edges_data_dict.get(component_id, 0)\n            components_data[component_id] = ComponentProperties(\n                component_id=component_id,\n                number_of_nodes=num_nodes,\n                number_of_associated_edge_rows=num_edges,\n            )\n\n        number_of_components = len(components_data)\n\n        result = cls(\n            number_of_nodes=num_rows,\n            properties_by_graph_type=props,\n            number_of_self_loops=num_self_loops,\n            number_of_components=number_of_components,\n            components={k: components_data[k] for k in sorted(components_data.keys())},\n        )\n        return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_nodes","title":"<code>number_of_nodes: int = Field(description='Number of nodes in the network graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.properties_by_graph_type","title":"<code>properties_by_graph_type: Dict[Literal[GraphType.DIRECTED.value, GraphType.UNDIRECTED.value, GraphType.UNDIRECTED_MULTI.value, GraphType.DIRECTED_MULTI.value], GraphProperties] = Field(description='Properties of the network data, by graph type.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_self_loops","title":"<code>number_of_self_loops: int = Field(description='Number of edges where source and target point to the same node.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.number_of_components","title":"<code>number_of_components: int = Field(description='Number of connected components in the network graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.components","title":"<code>components: Dict[int, ComponentProperties] = Field(description='Properties of the components of the network graph.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.retrieve_supported_data_types","title":"<code>retrieve_supported_data_types() -&gt; Iterable[str]</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef retrieve_supported_data_types(cls) -&gt; Iterable[str]:\n    return [\"network_data\"]\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models.NetworkGraphProperties.create_value_metadata","title":"<code>create_value_metadata(value: Value) -&gt; NetworkGraphProperties</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/models/__init__.py</code> <pre><code>@classmethod\ndef create_value_metadata(cls, value: Value) -&gt; \"NetworkGraphProperties\":\n    import duckdb\n\n    network_data: NetworkData = value.data\n\n    num_rows = network_data.num_nodes\n    num_edges = network_data.num_edges\n\n    # query_num_edges_directed = f\"SELECT COUNT(*) FROM (SELECT DISTINCT {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME} FROM {EDGES_TABLE_NAME})\"\n    query_num_edges_directed = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\"\n\n    num_edges_directed_result = network_data.query_edges(query_num_edges_directed)\n    num_edges_directed = num_edges_directed_result.columns[0][0].as_py()\n\n    query_num_edges_undirected = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 1\"\n    num_edges_undirected_result = network_data.query_edges(\n        query_num_edges_undirected\n    )\n    num_edges_undirected = num_edges_undirected_result.columns[0][0].as_py()\n\n    self_loop_query = f\"SELECT count(*) FROM {EDGES_TABLE_NAME} WHERE {SOURCE_COLUMN_NAME} = {TARGET_COLUMN_NAME}\"\n    self_loop_result = network_data.query_edges(self_loop_query)\n    num_self_loops = self_loop_result.columns[0][0].as_py()\n\n    num_parallel_edges_directed_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_DIRECTED_COLUMN_NAME} = 2\"\n    num_parallel_edges_directed_result = network_data.query_edges(\n        num_parallel_edges_directed_query\n    )\n    num_parallel_edges_directed = num_parallel_edges_directed_result.columns[0][\n        0\n    ].as_py()\n\n    num_parallel_edges_undirected_query = f\"SELECT COUNT(*) FROM {EDGES_TABLE_NAME} WHERE {COUNT_IDX_UNDIRECTED_COLUMN_NAME} = 2\"\n    num_parallel_edges_undirected_result = network_data.query_edges(\n        num_parallel_edges_undirected_query\n    )\n    num_parallel_edges_undirected = num_parallel_edges_undirected_result.columns[0][\n        0\n    ].as_py()\n\n    directed_props = GraphProperties(number_of_edges=num_edges_directed)\n    undirected_props = GraphProperties(number_of_edges=num_edges_undirected)\n    directed_multi_props = GraphProperties(\n        number_of_edges=num_edges, parallel_edges=num_parallel_edges_directed\n    )\n    undirected_multi_props = GraphProperties(\n        number_of_edges=num_edges, parallel_edges=num_parallel_edges_undirected\n    )\n\n    props = {\n        GraphType.DIRECTED.value: directed_props,\n        GraphType.DIRECTED_MULTI.value: directed_multi_props,\n        GraphType.UNDIRECTED.value: undirected_props,\n        GraphType.UNDIRECTED_MULTI.value: undirected_multi_props,\n    }\n\n    nodes_table = network_data.nodes.arrow_table  # noqa\n    edges_table = network_data.edges.arrow_table  # noqa\n\n    components_query_nodes = f\"\"\"\n        SELECT\n            {COMPONENT_ID_COLUMN_NAME}, COUNT(*)\n        FROM\n            nodes_table\n        GROUP BY {COMPONENT_ID_COLUMN_NAME}\n    \"\"\"\n    nodes_result = duckdb.query(components_query_nodes)\n    nodes_data = nodes_result.fetchall()\n    nodes_data_dict = {row[0]: row[1] for row in nodes_data}\n\n    components_query_edges = f\"\"\"\n        SELECT\n            {COMPONENT_ID_COLUMN_NAME}, COUNT(*)\n        FROM\n            edges_table\n        GROUP BY {COMPONENT_ID_COLUMN_NAME}\n    \"\"\"\n    edges_result = duckdb.query(components_query_edges)\n    edges_data = edges_result.fetchall()\n    edges_data_dict = {row[0]: row[1] for row in edges_data}\n\n    components_data = {}\n    for component_id, num_nodes in nodes_data_dict.items():\n        num_edges = edges_data_dict.get(component_id, 0)\n        components_data[component_id] = ComponentProperties(\n            component_id=component_id,\n            number_of_nodes=num_nodes,\n            number_of_associated_edge_rows=num_edges,\n        )\n\n    number_of_components = len(components_data)\n\n    result = cls(\n        number_of_nodes=num_rows,\n        properties_by_graph_type=props,\n        number_of_self_loops=num_self_loops,\n        number_of_components=number_of_components,\n        components={k: components_data[k] for k in sorted(components_data.keys())},\n    )\n    return result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/__init__/#kiara_plugin.network_analysis.models-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/","title":"metadata","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_ID_COLUMN_METADATA","title":"<code>NODE_ID_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_ID_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_LABEL_COLUMN_METADATA","title":"<code>NODE_LABEL_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_LABEL_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_EDGES_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_DEGREE_COLUMN_METADATA","title":"<code>NODE_DEGREE_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=UNWEIGHTED_DEGREE_CENTRALITY_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUND_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUND_EDGES_MULTI_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_DEGREE_MULTI_COLUMN_METADATA","title":"<code>NODE_DEGREE_MULTI_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=UNWEIGHTED_DEGREE_CENTRALITY_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_IN_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_IN_EDGES_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_IN_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUNT_IN_EDGES_MULTI_COLUMN_METADATA = NetworkNodeAttributeMetadata(doc=NODE_COUNT_IN_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_OUT_EDGES_COLUMN_METADATA","title":"<code>NODE_COUNT_OUT_EDGES_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=NODE_COUNT_OUT_EDGES_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA","title":"<code>NODE_COUNT_OUT_EDGES_MULTI_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=NODE_COUNT_OUT_EDGES_MULTI_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_ID_COLUMN_METADATA","title":"<code>EDGE_ID_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc='The unique id for the edge.', computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_SOURCE_COLUMN_METADATA","title":"<code>EDGE_SOURCE_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_SOURCE_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_TARGET_COLUMN_METADATA","title":"<code>EDGE_TARGET_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_TARGET_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA","title":"<code>EDGE_COUNT_DUP_DIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_COUNT_DUP_DIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA","title":"<code>EDGE_IDX_DUP_DIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_IDX_DUP_DIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA","title":"<code>EDGE_COUNT_DUP_UNDIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_COUNT_DUP_UNDIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA","title":"<code>EDGE_IDX_DUP_UNDIRECTED_COLUMN_METADATA = NetworkEdgeAttributeMetadata(doc=EDGE_IDX_DUP_UNDIRECTED_TEXT, computed_attribute=True)</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata","title":"<code>NetworkNodeAttributeMetadata</code>","text":"<p>               Bases: <code>KiaraModel</code></p> Source code in <code>src/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>class NetworkNodeAttributeMetadata(KiaraModel):\n    _kiara_model_id: ClassVar = \"metadata.network_node_attribute\"\n\n    doc: DocumentationMetadataModel = Field(\n        description=\"Explanation what this attribute is about.\",\n        default_factory=DocumentationMetadataModel.create,\n    )\n    computed_attribute: bool = Field(\n        description=\"Whether this is the default attribute that is always automatically added by kiara.\",\n        default=False,\n    )\n\n    @field_validator(\"doc\", mode=\"before\")\n    @classmethod\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Explanation what this attribute is about.', default_factory=DocumentationMetadataModel.create)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.computed_attribute","title":"<code>computed_attribute: bool = Field(description='Whether this is the default attribute that is always automatically added by kiara.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkNodeAttributeMetadata.validate_doc","title":"<code>validate_doc(value)</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>@field_validator(\"doc\", mode=\"before\")\n@classmethod\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata","title":"<code>NetworkEdgeAttributeMetadata</code>","text":"<p>               Bases: <code>KiaraModel</code></p> Source code in <code>src/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>class NetworkEdgeAttributeMetadata(KiaraModel):\n    _kiara_model_id: ClassVar = \"metadata.network_edge_attribute\"\n\n    doc: DocumentationMetadataModel = Field(\n        description=\"Explanation what this attribute is about.\",\n        default_factory=DocumentationMetadataModel.create,\n    )\n    computed_attribute: bool = Field(\n        description=\"Whether this is the computed attribute that is automatically added by kiara.\",\n        default=False,\n    )\n\n    @field_validator(\"doc\", mode=\"before\")\n    @classmethod\n    def validate_doc(cls, value):\n        return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.doc","title":"<code>doc: DocumentationMetadataModel = Field(description='Explanation what this attribute is about.', default_factory=DocumentationMetadataModel.create)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.computed_attribute","title":"<code>computed_attribute: bool = Field(description='Whether this is the computed attribute that is automatically added by kiara.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/models/metadata/#kiara_plugin.network_analysis.models.metadata.NetworkEdgeAttributeMetadata.validate_doc","title":"<code>validate_doc(value)</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/models/metadata.py</code> <pre><code>@field_validator(\"doc\", mode=\"before\")\n@classmethod\ndef validate_doc(cls, value):\n    return DocumentationMetadataModel.create(value)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/__init__/","title":"modules","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/","title":"create","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.KIARA_METADATA","title":"<code>KIARA_METADATA = {'authors': [{'name': 'Lena Jaskov', 'email': 'helena.jaskov@uni.lu'}, {'name': 'Markus Binsteiner', 'email': 'markus@frkl.io'}], 'description': 'Modules to create/export network data.'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig","title":"<code>CreateNetworkDataModuleConfig</code>","text":"<p>               Bases: <code>CreateFromModuleConfig</code></p> Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class CreateNetworkDataModuleConfig(CreateFromModuleConfig):\n    ignore_errors: bool = Field(\n        description=\"Whether to ignore convert errors and omit the failed items.\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModuleConfig.ignore_errors","title":"<code>ignore_errors: bool = Field(description='Whether to ignore convert errors and omit the failed items.', default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule","title":"<code>CreateNetworkDataModule</code>","text":"<p>               Bases: <code>CreateFromModule</code></p> Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class CreateNetworkDataModule(CreateFromModule):\n    _module_type_name = \"create.network_data\"\n    _config_cls = CreateNetworkDataModuleConfig\n\n    def create__network_data__from__file(self, source_value: Value) -&gt; Any:\n        \"\"\"Create a table from a file, trying to auto-determine the format of said file.\n\n        Supported file formats (at the moment):\n        - gml\n        - gexf\n        - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)\n        - pajek\n        - leda\n        - graph6\n        - sparse6\n        \"\"\"\n\n        source_file: KiaraFile = source_value.data\n        # the name of the attribute kiara should use to populate the node labels\n        label_attr_name: Union[str, None] = None\n        # attributes to ignore when creating the node table,\n        # mostly useful if we know that the file contains attributes that are not relevant for the network\n        # or for 'label', if we don't want to duplicate the information in '_label' and 'label'\n        ignore_node_attributes = None\n\n        if source_file.file_name.endswith(\".gml\"):\n            import networkx as nx\n\n            # we use 'lable=\"id\"' here because networkx is fussy about labels being unique and non-null\n            # we use the 'label' attribute for the node labels manually later\n            graph = nx.read_gml(source_file.path, label=\"id\")\n            label_attr_name = \"label\"\n            ignore_node_attributes = [\"label\"]\n\n        elif source_file.file_name.endswith(\".gexf\"):\n            import networkx as nx\n\n            graph = nx.read_gexf(source_file.path)\n        elif source_file.file_name.endswith(\".graphml\"):\n            import networkx as nx\n\n            graph = nx.read_graphml(source_file.path)\n        elif source_file.file_name.endswith(\".pajek\") or source_file.file_name.endswith(\n            \".net\"\n        ):\n            import networkx as nx\n\n            graph = nx.read_pajek(source_file.path)\n        elif source_file.file_name.endswith(\".leda\"):\n            import networkx as nx\n\n            graph = nx.read_leda(source_file.path)\n        elif source_file.file_name.endswith(\n            \".graph6\"\n        ) or source_file.file_name.endswith(\".g6\"):\n            import networkx as nx\n\n            graph = nx.read_graph6(source_file.path)\n        elif source_file.file_name.endswith(\n            \".sparse6\"\n        ) or source_file.file_name.endswith(\".s6\"):\n            import networkx as nx\n\n            graph = nx.read_sparse6(source_file.path)\n        else:\n            supported_file_estensions = [\n                \"gml\",\n                \"gexf\",\n                \"graphml\",\n                \"pajek\",\n                \"leda\",\n                \"graph6\",\n                \"g6\",\n                \"sparse6\",\n                \"s6\",\n            ]\n\n            msg = f\"Can't create network data for unsupported format of file: {source_file.file_name}. Supported file extensions: {', '.join(supported_file_estensions)}\"\n\n            raise KiaraProcessingException(msg)\n\n        return NetworkData.create_from_networkx_graph(\n            graph=graph,\n            label_attr_name=label_attr_name,\n            ignore_node_attributes=ignore_node_attributes,\n        )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule._config_cls","title":"<code>_config_cls = CreateNetworkDataModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.CreateNetworkDataModule.create__network_data__from__file","title":"<code>create__network_data__from__file(source_value: Value) -&gt; Any</code>","text":"<p>Create a table from a file, trying to auto-determine the format of said file.</p> <p>Supported file formats (at the moment): - gml - gexf - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust) - pajek - leda - graph6 - sparse6</p> Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create__network_data__from__file(self, source_value: Value) -&gt; Any:\n    \"\"\"Create a table from a file, trying to auto-determine the format of said file.\n\n    Supported file formats (at the moment):\n    - gml\n    - gexf\n    - graphml (uses the standard xml library present in Python, which is insecure - see xml for additional information. Only parse GraphML files you trust)\n    - pajek\n    - leda\n    - graph6\n    - sparse6\n    \"\"\"\n\n    source_file: KiaraFile = source_value.data\n    # the name of the attribute kiara should use to populate the node labels\n    label_attr_name: Union[str, None] = None\n    # attributes to ignore when creating the node table,\n    # mostly useful if we know that the file contains attributes that are not relevant for the network\n    # or for 'label', if we don't want to duplicate the information in '_label' and 'label'\n    ignore_node_attributes = None\n\n    if source_file.file_name.endswith(\".gml\"):\n        import networkx as nx\n\n        # we use 'lable=\"id\"' here because networkx is fussy about labels being unique and non-null\n        # we use the 'label' attribute for the node labels manually later\n        graph = nx.read_gml(source_file.path, label=\"id\")\n        label_attr_name = \"label\"\n        ignore_node_attributes = [\"label\"]\n\n    elif source_file.file_name.endswith(\".gexf\"):\n        import networkx as nx\n\n        graph = nx.read_gexf(source_file.path)\n    elif source_file.file_name.endswith(\".graphml\"):\n        import networkx as nx\n\n        graph = nx.read_graphml(source_file.path)\n    elif source_file.file_name.endswith(\".pajek\") or source_file.file_name.endswith(\n        \".net\"\n    ):\n        import networkx as nx\n\n        graph = nx.read_pajek(source_file.path)\n    elif source_file.file_name.endswith(\".leda\"):\n        import networkx as nx\n\n        graph = nx.read_leda(source_file.path)\n    elif source_file.file_name.endswith(\n        \".graph6\"\n    ) or source_file.file_name.endswith(\".g6\"):\n        import networkx as nx\n\n        graph = nx.read_graph6(source_file.path)\n    elif source_file.file_name.endswith(\n        \".sparse6\"\n    ) or source_file.file_name.endswith(\".s6\"):\n        import networkx as nx\n\n        graph = nx.read_sparse6(source_file.path)\n    else:\n        supported_file_estensions = [\n            \"gml\",\n            \"gexf\",\n            \"graphml\",\n            \"pajek\",\n            \"leda\",\n            \"graph6\",\n            \"g6\",\n            \"sparse6\",\n            \"s6\",\n        ]\n\n        msg = f\"Can't create network data for unsupported format of file: {source_file.file_name}. Supported file extensions: {', '.join(supported_file_estensions)}\"\n\n        raise KiaraProcessingException(msg)\n\n    return NetworkData.create_from_networkx_graph(\n        graph=graph,\n        label_attr_name=label_attr_name,\n        ignore_node_attributes=ignore_node_attributes,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig","title":"<code>AssembleNetworkDataModuleConfig</code>","text":"<p>               Bases: <code>KiaraModuleConfig</code></p> Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class AssembleNetworkDataModuleConfig(KiaraModuleConfig):\n    node_id_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the node id column.\",\n        default=NODE_ID_ALIAS_NAMES,\n    )  # pydantic should handle that correctly (deepcopy) -- and anyway, it's immutable (hopefully)\n    label_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the node label column.\",\n        default=LABEL_ALIAS_NAMES,\n    )\n    source_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the source column.\",\n        default=SOURCE_COLUMN_ALIAS_NAMES,\n    )\n    target_column_aliases: List[str] = Field(\n        description=\"Alias strings to test (in order) for auto-detecting the target column.\",\n        default=TARGET_COLUMN_ALIAS_NAMES,\n    )\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.node_id_column_aliases","title":"<code>node_id_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the node id column.', default=NODE_ID_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.label_column_aliases","title":"<code>label_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the node label column.', default=LABEL_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.source_column_aliases","title":"<code>source_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the source column.', default=SOURCE_COLUMN_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleNetworkDataModuleConfig.target_column_aliases","title":"<code>target_column_aliases: List[str] = Field(description='Alias strings to test (in order) for auto-detecting the target column.', default=TARGET_COLUMN_ALIAS_NAMES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule","title":"<code>AssembleGraphFromTablesModule</code>","text":"<p>               Bases: <code>KiaraModule</code></p> <p>Create a 'network_data' instance from one or two tables.</p> <p>This module needs at least one table as input, providing the edges of the resulting network data set. If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.</p> <p>If no <code>source_column_name</code> (and/or <code>target_column_name</code>) is provided, kiara will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.</p> Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>class AssembleGraphFromTablesModule(KiaraModule):\n    \"\"\"Create a 'network_data' instance from one or two tables.\n\n    This module needs at least one table as input, providing the edges of the resulting network data set.\n    If no further table is created, basic node information will be automatically created by using unique values from the edges source and target columns.\n\n    If no `source_column_name` (and/or `target_column_name`) is provided, *kiara* will try to auto-detect the most likely of the existing columns to use. If that is not possible, an error will be raised.\n    \"\"\"\n\n    _module_type_name = \"assemble.network_data\"\n    _config_cls = AssembleNetworkDataModuleConfig\n\n    def create_inputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        inputs: Mapping[str, Any] = {\n            \"edges\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the edges data.\",\n                \"optional\": False,\n            },\n            \"source_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the source column name in the edges table.\",\n                \"optional\": True,\n            },\n            \"target_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of the target column name in the edges table.\",\n                \"optional\": True,\n            },\n            \"edges_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n            \"nodes\": {\n                \"type\": \"table\",\n                \"doc\": \"A table that contains the nodes data.\",\n                \"optional\": True,\n            },\n            \"id_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n                \"optional\": True,\n            },\n            \"label_column\": {\n                \"type\": \"string\",\n                \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n                \"optional\": True,\n            },\n            \"nodes_column_map\": {\n                \"type\": \"dict\",\n                \"doc\": \"An optional map of original column name to desired.\",\n                \"optional\": True,\n            },\n        }\n        return inputs\n\n    def create_outputs_schema(\n        self,\n    ) -&gt; ValueMapSchema:\n        outputs: Mapping[str, Any] = {\n            \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n        }\n        return outputs\n\n    def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n        import polars as pl\n\n        # process nodes\n        nodes = inputs.get_value_obj(\"nodes\")\n\n        # the nodes column map can be used to rename attribute columns in the nodes table\n        nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n        if nodes_column_map is None:\n            nodes_column_map = {}\n\n        # we need to process the nodes first, because if we have nodes, we need to create the node id map that translates from the original\n        # id to the new, internal, integer-based one\n\n        if nodes.is_set:\n            job_log.add_log(\"processing nodes table\")\n\n            nodes_table: KiaraTable = nodes.data\n            assert nodes_table is not None\n\n            nodes_column_names = nodes_table.column_names\n\n            # the most important column is the id column, which is the only one that we absolutely need to have\n            id_column_name = inputs.get_value_data(\"id_column\")\n\n            if id_column_name is None:\n                # try to auto-detect the id column\n                column_names_to_test = self.get_config_value(\"node_id_column_aliases\")\n                id_column_name = guess_node_id_column_name(\n                    nodes_table=nodes_table, suggestions=column_names_to_test\n                )\n\n                if id_column_name is None:\n                    raise KiaraProcessingException(\n                        f\"Could not auto-determine id column name. Please specify one manually, using one of: {', '.join(nodes_column_names)}\"\n                    )\n                else:\n                    job_log.add_log(f\"auto-detected id column: {id_column_name}\")\n\n            if id_column_name not in nodes_column_names:\n                raise KiaraProcessingException(\n                    f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n\n            nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n            if id_column_name in nodes_column_map.keys():\n                if nodes_column_map[id_column_name] != NODE_ID_COLUMN_NAME:\n                    raise KiaraProcessingException(\n                        f\"Existing mapping of id column name '{id_column_name}' is not mapped to '{NODE_ID_COLUMN_NAME}' in the 'nodes_column_map' input.\"\n                    )\n            else:\n                nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n\n            # the label is optional, if not specified, we try to auto-detect it. If not possible, we will use the (stringified) id column as label.\n            label_column_name = inputs.get_value_data(\"label_column\")\n            if label_column_name is None:\n                column_names_to_test = self.get_config_value(\"label_column_aliases\")\n                label_column_name = guess_node_label_column_name(\n                    nodes_table=nodes_table, suggestions=column_names_to_test\n                )\n\n                if label_column_name and label_column_name not in nodes_column_names:\n                    raise KiaraProcessingException(\n                        f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n                    )\n\n                if label_column_name is not None:\n                    job_log.add_log(f\"auto-detected label column: {label_column_name}\")\n                else:\n                    job_log.add_log(\n                        \"no label column found, will use id column as label\"\n                    )\n\n            nodes_arrow_dataframe = nodes_table.to_polars_dataframe()\n\n        else:\n            nodes_arrow_dataframe = None\n            label_column_name = None\n\n        # process edges\n\n        job_log.add_log(\"processing edges table\")\n        edges = inputs.get_value_obj(\"edges\")\n        edges_table: KiaraTable = edges.data\n        edges_source_column_name = inputs.get_value_data(\"source_column\")\n        edges_target_column_name = inputs.get_value_data(\"target_column\")\n\n        edges_arrow_dataframe = edges_table.to_polars_dataframe()\n        edges_column_names = edges_arrow_dataframe.columns\n\n        if edges_source_column_name is None:\n            column_names_to_test = self.get_config_value(\"source_column_aliases\")\n            edges_source_column_name = guess_source_column_name(\n                edges_table=edges_table, suggestions=column_names_to_test\n            )\n            if edges_target_column_name is not None:\n                job_log.add_log(\n                    f\"auto-detected source column: {edges_source_column_name}\"\n                )\n\n        if edges_target_column_name is None:\n            column_names_to_test = self.get_config_value(\"target_column_aliases\")\n            edges_target_column_name = guess_target_column_name(\n                edges_table=edges_table, suggestions=column_names_to_test\n            )\n            if edges_target_column_name is not None:\n                job_log.add_log(\n                    f\"auto-detected target column: {edges_target_column_name}\"\n                )\n\n        if not edges_source_column_name or not edges_target_column_name:\n            if not edges_source_column_name and not edges_target_column_name:\n                if len(edges_column_names) == 2:\n                    job_log.add_log(\n                        \"using first two columns as source and target columns\"\n                    )\n                    edges_source_column_name = edges_column_names[0]\n                    edges_target_column_name = edges_column_names[1]\n                else:\n                    raise KiaraProcessingException(\n                        f\"Could not auto-detect source and target column names. Please specify them manually using one of: {', '.join(edges_column_names)}.\"\n                    )\n\n            if not edges_source_column_name:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect source column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n            if not edges_target_column_name:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect target column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n        edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n        if edges_column_map is None:\n            edges_column_map = {}\n\n        if edges_source_column_name in edges_column_map.keys():\n            if edges_column_map[edges_source_column_name] != SOURCE_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of source column name '{edges_source_column_name}' is not mapped to '{SOURCE_COLUMN_NAME}' in the 'edges_column_map' input.\"\n                )\n        else:\n            edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n\n        if edges_target_column_name in edges_column_map.keys():\n            if edges_column_map[edges_target_column_name] == SOURCE_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    msg=\"Edges and source column names can't be the same.\"\n                )\n            if edges_column_map[edges_target_column_name] != TARGET_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of target column name '{edges_target_column_name}' is not mapped to '{TARGET_COLUMN_NAME}' in the 'edges_column_map' input.\"\n                )\n        else:\n            edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n        if edges_source_column_name not in edges_column_names:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n            )\n        if edges_target_column_name not in edges_column_names:\n            raise KiaraProcessingException(\n                f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n            )\n\n        source_column_old = edges_arrow_dataframe.get_column(edges_source_column_name)\n        target_column_old = edges_arrow_dataframe.get_column(edges_target_column_name)\n\n        source_column_old_str = source_column_old.cast(pl.Utf8)\n        target_column_old_str = target_column_old.cast(pl.Utf8)\n\n        job_log.add_log(\"generating node id map and nodes table\")\n        # fill out the node id map\n        unique_node_ids_old = (\n            pl.concat([source_column_old_str, target_column_old_str], rechunk=False)\n            .unique()\n            .sort()\n        )\n\n        if nodes_arrow_dataframe is None:\n            new_node_ids = range(0, len(unique_node_ids_old))  # noqa: PIE808\n            node_id_map = dict(zip(unique_node_ids_old, new_node_ids))\n            # node_id_map = {\n            #     node_id: new_node_id\n            #     for node_id, new_node_id in\n            # }\n\n            nodes_arrow_dataframe = pl.DataFrame(\n                {\n                    NODE_ID_COLUMN_NAME: new_node_ids,\n                    LABEL_COLUMN_NAME: unique_node_ids_old,\n                    \"id\": unique_node_ids_old,\n                }\n            )\n\n        else:\n            id_column_old = nodes_arrow_dataframe.get_column(id_column_name)\n            id_column_old_str = id_column_old.cast(pl.Utf8)\n            unique_node_ids_nodes_table = id_column_old_str.unique().sort()\n\n            missing_node_ids = unique_node_ids_old.filter(\n                ~unique_node_ids_old.is_in(unique_node_ids_nodes_table)\n            )\n\n            # replace the id column with the stringified version\n            idx_column_old = nodes_arrow_dataframe.get_column_index(id_column_name)\n            nodes_arrow_dataframe = nodes_arrow_dataframe.replace_column(\n                idx_column_old, id_column_old_str\n            )\n\n            # Create a new dataframe with missing nodes\n            if len(missing_node_ids) &gt; 0:\n                # Get the schema from the existing nodes dataframe\n                missing_nodes_data = {}\n\n                # cast the missing_node_ids to a list of strings\n                missing_node_ids = missing_node_ids.cast(pl.Utf8)\n\n                # Set the node ID column (before mapping) with the missing IDs\n                missing_nodes_data[id_column_name] = missing_node_ids\n\n                # Fill other columns with None values\n                for col_name in nodes_arrow_dataframe.columns:\n                    if col_name == label_column_name:\n                        missing_nodes_data[col_name] = missing_node_ids\n                    elif col_name != id_column_name:\n                        # Create a series of None values with the same length as missing_node_ids\n                        missing_nodes_data[col_name] = [None] * len(missing_node_ids)  # type: ignore\n\n                # Create the new dataframe\n                missing_nodes_df = pl.DataFrame(missing_nodes_data)\n\n                # Concatenate with the existing nodes dataframe\n                nodes_arrow_dataframe = pl.concat(\n                    [nodes_arrow_dataframe, missing_nodes_df]\n                )\n                id_column_old_str = nodes_arrow_dataframe.get_column(id_column_name)\n\n            new_node_ids = range(0, len(id_column_old_str))  # noqa: PIE808\n            node_id_map = dict(zip(id_column_old_str, new_node_ids))\n\n            new_idx_series = pl.Series(name=NODE_ID_COLUMN_NAME, values=new_node_ids)\n\n            nodes_arrow_dataframe.insert_column(0, new_idx_series)\n\n            if not label_column_name:\n                label_column_name = NODE_ID_COLUMN_NAME\n\n            # we create a copy of the label column, and stringify its items\n\n            label_column = nodes_arrow_dataframe.get_column(label_column_name).rename(\n                LABEL_COLUMN_NAME\n            )\n            if label_column.dtype != pl.Utf8:\n                label_column = label_column.cast(pl.Utf8)\n\n            if label_column.null_count() != 0:\n                raise KiaraProcessingException(\n                    f\"Label column '{label_column_name}' contains null values. This is not allowed.\"\n                )\n\n            nodes_arrow_dataframe = nodes_arrow_dataframe.insert_column(1, label_column)\n\n        # TODO: deal with different types if node ids are strings or integers\n        try:\n            source_column_mapped = source_column_old_str.replace_strict(\n                node_id_map, default=None\n            ).rename(SOURCE_COLUMN_NAME)\n        except Exception:\n            raise KiaraProcessingException(\n                \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the source column of your edges table.\"\n            )\n\n        if source_column_mapped.is_null().any():\n            raise KiaraProcessingException(\n                \"The source column contains values that are not mapped in the nodes table.\"\n            )\n\n        try:\n            target_column_mapped = target_column_old_str.replace_strict(\n                node_id_map, default=None\n            ).rename(TARGET_COLUMN_NAME)\n        except Exception:\n            raise KiaraProcessingException(\n                \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the target column of your edges table.\"\n            )\n\n        if target_column_mapped.is_null().any():\n            raise KiaraProcessingException(\n                \"The target column contains values that are not mapped in the nodes table.\"\n            )\n\n        edges_arrow_dataframe.insert_column(0, source_column_mapped)\n        edges_arrow_dataframe.insert_column(1, target_column_mapped)\n\n        edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_source_column_name)\n        edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_target_column_name)\n\n        edges_arrow_table = edges_arrow_dataframe.to_arrow()\n        # edges_table_augmented = augment_edges_table_with_weights(edges_arrow_dataframe)\n\n        # # TODO: also index the other columns?\n        # edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n        #     table=edges_arrow_dataframe,\n        #     index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n        #     column_map=edges_column_map,\n        # )\n\n        nodes_arrow_table = nodes_arrow_dataframe.to_arrow()\n\n        job_log.add_log(\"creating network data instance\")\n        network_data = NetworkData.create_network_data(\n            nodes_table=nodes_arrow_table, edges_table=edges_arrow_table\n        )\n\n        outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule._config_cls","title":"<code>_config_cls = AssembleNetworkDataModuleConfig</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.create_inputs_schema","title":"<code>create_inputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create_inputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    inputs: Mapping[str, Any] = {\n        \"edges\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the edges data.\",\n            \"optional\": False,\n        },\n        \"source_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the source column name in the edges table.\",\n            \"optional\": True,\n        },\n        \"target_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of the target column name in the edges table.\",\n            \"optional\": True,\n        },\n        \"edges_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n        \"nodes\": {\n            \"type\": \"table\",\n            \"doc\": \"A table that contains the nodes data.\",\n            \"optional\": True,\n        },\n        \"id_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name (before any potential column mapping) of the node-table column that contains the node identifier (used in the edges table).\",\n            \"optional\": True,\n        },\n        \"label_column\": {\n            \"type\": \"string\",\n            \"doc\": \"The name of a column that contains the node label (before any potential column name mapping). If not specified, the value of the id value will be used as label.\",\n            \"optional\": True,\n        },\n        \"nodes_column_map\": {\n            \"type\": \"dict\",\n            \"doc\": \"An optional map of original column name to desired.\",\n            \"optional\": True,\n        },\n    }\n    return inputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.create_outputs_schema","title":"<code>create_outputs_schema() -&gt; ValueMapSchema</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def create_outputs_schema(\n    self,\n) -&gt; ValueMapSchema:\n    outputs: Mapping[str, Any] = {\n        \"network_data\": {\"type\": \"network_data\", \"doc\": \"The network/graph data.\"}\n    }\n    return outputs\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create.AssembleGraphFromTablesModule.process","title":"<code>process(inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/create.py</code> <pre><code>def process(self, inputs: ValueMap, outputs: ValueMap, job_log: JobLog) -&gt; None:\n    import polars as pl\n\n    # process nodes\n    nodes = inputs.get_value_obj(\"nodes\")\n\n    # the nodes column map can be used to rename attribute columns in the nodes table\n    nodes_column_map: Dict[str, str] = inputs.get_value_data(\"nodes_column_map\")\n    if nodes_column_map is None:\n        nodes_column_map = {}\n\n    # we need to process the nodes first, because if we have nodes, we need to create the node id map that translates from the original\n    # id to the new, internal, integer-based one\n\n    if nodes.is_set:\n        job_log.add_log(\"processing nodes table\")\n\n        nodes_table: KiaraTable = nodes.data\n        assert nodes_table is not None\n\n        nodes_column_names = nodes_table.column_names\n\n        # the most important column is the id column, which is the only one that we absolutely need to have\n        id_column_name = inputs.get_value_data(\"id_column\")\n\n        if id_column_name is None:\n            # try to auto-detect the id column\n            column_names_to_test = self.get_config_value(\"node_id_column_aliases\")\n            id_column_name = guess_node_id_column_name(\n                nodes_table=nodes_table, suggestions=column_names_to_test\n            )\n\n            if id_column_name is None:\n                raise KiaraProcessingException(\n                    f\"Could not auto-determine id column name. Please specify one manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n            else:\n                job_log.add_log(f\"auto-detected id column: {id_column_name}\")\n\n        if id_column_name not in nodes_column_names:\n            raise KiaraProcessingException(\n                f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n            )\n\n        nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n        if id_column_name in nodes_column_map.keys():\n            if nodes_column_map[id_column_name] != NODE_ID_COLUMN_NAME:\n                raise KiaraProcessingException(\n                    f\"Existing mapping of id column name '{id_column_name}' is not mapped to '{NODE_ID_COLUMN_NAME}' in the 'nodes_column_map' input.\"\n                )\n        else:\n            nodes_column_map[id_column_name] = NODE_ID_COLUMN_NAME\n\n        # the label is optional, if not specified, we try to auto-detect it. If not possible, we will use the (stringified) id column as label.\n        label_column_name = inputs.get_value_data(\"label_column\")\n        if label_column_name is None:\n            column_names_to_test = self.get_config_value(\"label_column_aliases\")\n            label_column_name = guess_node_label_column_name(\n                nodes_table=nodes_table, suggestions=column_names_to_test\n            )\n\n            if label_column_name and label_column_name not in nodes_column_names:\n                raise KiaraProcessingException(\n                    f\"Could not find id column '{id_column_name}' in the nodes table. Please specify a valid column name manually, using one of: {', '.join(nodes_column_names)}\"\n                )\n\n            if label_column_name is not None:\n                job_log.add_log(f\"auto-detected label column: {label_column_name}\")\n            else:\n                job_log.add_log(\n                    \"no label column found, will use id column as label\"\n                )\n\n        nodes_arrow_dataframe = nodes_table.to_polars_dataframe()\n\n    else:\n        nodes_arrow_dataframe = None\n        label_column_name = None\n\n    # process edges\n\n    job_log.add_log(\"processing edges table\")\n    edges = inputs.get_value_obj(\"edges\")\n    edges_table: KiaraTable = edges.data\n    edges_source_column_name = inputs.get_value_data(\"source_column\")\n    edges_target_column_name = inputs.get_value_data(\"target_column\")\n\n    edges_arrow_dataframe = edges_table.to_polars_dataframe()\n    edges_column_names = edges_arrow_dataframe.columns\n\n    if edges_source_column_name is None:\n        column_names_to_test = self.get_config_value(\"source_column_aliases\")\n        edges_source_column_name = guess_source_column_name(\n            edges_table=edges_table, suggestions=column_names_to_test\n        )\n        if edges_target_column_name is not None:\n            job_log.add_log(\n                f\"auto-detected source column: {edges_source_column_name}\"\n            )\n\n    if edges_target_column_name is None:\n        column_names_to_test = self.get_config_value(\"target_column_aliases\")\n        edges_target_column_name = guess_target_column_name(\n            edges_table=edges_table, suggestions=column_names_to_test\n        )\n        if edges_target_column_name is not None:\n            job_log.add_log(\n                f\"auto-detected target column: {edges_target_column_name}\"\n            )\n\n    if not edges_source_column_name or not edges_target_column_name:\n        if not edges_source_column_name and not edges_target_column_name:\n            if len(edges_column_names) == 2:\n                job_log.add_log(\n                    \"using first two columns as source and target columns\"\n                )\n                edges_source_column_name = edges_column_names[0]\n                edges_target_column_name = edges_column_names[1]\n            else:\n                raise KiaraProcessingException(\n                    f\"Could not auto-detect source and target column names. Please specify them manually using one of: {', '.join(edges_column_names)}.\"\n                )\n\n        if not edges_source_column_name:\n            raise KiaraProcessingException(\n                f\"Could not auto-detect source column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n            )\n\n        if not edges_target_column_name:\n            raise KiaraProcessingException(\n                f\"Could not auto-detect target column name. Please specify it manually using one of: {', '.join(edges_column_names)}.\"\n            )\n\n    edges_column_map: Dict[str, str] = inputs.get_value_data(\"edges_column_map\")\n    if edges_column_map is None:\n        edges_column_map = {}\n\n    if edges_source_column_name in edges_column_map.keys():\n        if edges_column_map[edges_source_column_name] != SOURCE_COLUMN_NAME:\n            raise KiaraProcessingException(\n                f\"Existing mapping of source column name '{edges_source_column_name}' is not mapped to '{SOURCE_COLUMN_NAME}' in the 'edges_column_map' input.\"\n            )\n    else:\n        edges_column_map[edges_source_column_name] = SOURCE_COLUMN_NAME\n\n    if edges_target_column_name in edges_column_map.keys():\n        if edges_column_map[edges_target_column_name] == SOURCE_COLUMN_NAME:\n            raise KiaraProcessingException(\n                msg=\"Edges and source column names can't be the same.\"\n            )\n        if edges_column_map[edges_target_column_name] != TARGET_COLUMN_NAME:\n            raise KiaraProcessingException(\n                f\"Existing mapping of target column name '{edges_target_column_name}' is not mapped to '{TARGET_COLUMN_NAME}' in the 'edges_column_map' input.\"\n            )\n    else:\n        edges_column_map[edges_target_column_name] = TARGET_COLUMN_NAME\n\n    if edges_source_column_name not in edges_column_names:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain source column '{edges_source_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n        )\n    if edges_target_column_name not in edges_column_names:\n        raise KiaraProcessingException(\n            f\"Edges table does not contain target column '{edges_target_column_name}'. Choose one of: {', '.join(edges_column_names)}.\"\n        )\n\n    source_column_old = edges_arrow_dataframe.get_column(edges_source_column_name)\n    target_column_old = edges_arrow_dataframe.get_column(edges_target_column_name)\n\n    source_column_old_str = source_column_old.cast(pl.Utf8)\n    target_column_old_str = target_column_old.cast(pl.Utf8)\n\n    job_log.add_log(\"generating node id map and nodes table\")\n    # fill out the node id map\n    unique_node_ids_old = (\n        pl.concat([source_column_old_str, target_column_old_str], rechunk=False)\n        .unique()\n        .sort()\n    )\n\n    if nodes_arrow_dataframe is None:\n        new_node_ids = range(0, len(unique_node_ids_old))  # noqa: PIE808\n        node_id_map = dict(zip(unique_node_ids_old, new_node_ids))\n        # node_id_map = {\n        #     node_id: new_node_id\n        #     for node_id, new_node_id in\n        # }\n\n        nodes_arrow_dataframe = pl.DataFrame(\n            {\n                NODE_ID_COLUMN_NAME: new_node_ids,\n                LABEL_COLUMN_NAME: unique_node_ids_old,\n                \"id\": unique_node_ids_old,\n            }\n        )\n\n    else:\n        id_column_old = nodes_arrow_dataframe.get_column(id_column_name)\n        id_column_old_str = id_column_old.cast(pl.Utf8)\n        unique_node_ids_nodes_table = id_column_old_str.unique().sort()\n\n        missing_node_ids = unique_node_ids_old.filter(\n            ~unique_node_ids_old.is_in(unique_node_ids_nodes_table)\n        )\n\n        # replace the id column with the stringified version\n        idx_column_old = nodes_arrow_dataframe.get_column_index(id_column_name)\n        nodes_arrow_dataframe = nodes_arrow_dataframe.replace_column(\n            idx_column_old, id_column_old_str\n        )\n\n        # Create a new dataframe with missing nodes\n        if len(missing_node_ids) &gt; 0:\n            # Get the schema from the existing nodes dataframe\n            missing_nodes_data = {}\n\n            # cast the missing_node_ids to a list of strings\n            missing_node_ids = missing_node_ids.cast(pl.Utf8)\n\n            # Set the node ID column (before mapping) with the missing IDs\n            missing_nodes_data[id_column_name] = missing_node_ids\n\n            # Fill other columns with None values\n            for col_name in nodes_arrow_dataframe.columns:\n                if col_name == label_column_name:\n                    missing_nodes_data[col_name] = missing_node_ids\n                elif col_name != id_column_name:\n                    # Create a series of None values with the same length as missing_node_ids\n                    missing_nodes_data[col_name] = [None] * len(missing_node_ids)  # type: ignore\n\n            # Create the new dataframe\n            missing_nodes_df = pl.DataFrame(missing_nodes_data)\n\n            # Concatenate with the existing nodes dataframe\n            nodes_arrow_dataframe = pl.concat(\n                [nodes_arrow_dataframe, missing_nodes_df]\n            )\n            id_column_old_str = nodes_arrow_dataframe.get_column(id_column_name)\n\n        new_node_ids = range(0, len(id_column_old_str))  # noqa: PIE808\n        node_id_map = dict(zip(id_column_old_str, new_node_ids))\n\n        new_idx_series = pl.Series(name=NODE_ID_COLUMN_NAME, values=new_node_ids)\n\n        nodes_arrow_dataframe.insert_column(0, new_idx_series)\n\n        if not label_column_name:\n            label_column_name = NODE_ID_COLUMN_NAME\n\n        # we create a copy of the label column, and stringify its items\n\n        label_column = nodes_arrow_dataframe.get_column(label_column_name).rename(\n            LABEL_COLUMN_NAME\n        )\n        if label_column.dtype != pl.Utf8:\n            label_column = label_column.cast(pl.Utf8)\n\n        if label_column.null_count() != 0:\n            raise KiaraProcessingException(\n                f\"Label column '{label_column_name}' contains null values. This is not allowed.\"\n            )\n\n        nodes_arrow_dataframe = nodes_arrow_dataframe.insert_column(1, label_column)\n\n    # TODO: deal with different types if node ids are strings or integers\n    try:\n        source_column_mapped = source_column_old_str.replace_strict(\n            node_id_map, default=None\n        ).rename(SOURCE_COLUMN_NAME)\n    except Exception:\n        raise KiaraProcessingException(\n            \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the source column of your edges table.\"\n        )\n\n    if source_column_mapped.is_null().any():\n        raise KiaraProcessingException(\n            \"The source column contains values that are not mapped in the nodes table.\"\n        )\n\n    try:\n        target_column_mapped = target_column_old_str.replace_strict(\n            node_id_map, default=None\n        ).rename(TARGET_COLUMN_NAME)\n    except Exception:\n        raise KiaraProcessingException(\n            \"Could not map node ids onto edges source column.  In most cases the issue is that your node ids have a different data type in your nodes table as in the target column of your edges table.\"\n        )\n\n    if target_column_mapped.is_null().any():\n        raise KiaraProcessingException(\n            \"The target column contains values that are not mapped in the nodes table.\"\n        )\n\n    edges_arrow_dataframe.insert_column(0, source_column_mapped)\n    edges_arrow_dataframe.insert_column(1, target_column_mapped)\n\n    edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_source_column_name)\n    edges_arrow_dataframe = edges_arrow_dataframe.drop(edges_target_column_name)\n\n    edges_arrow_table = edges_arrow_dataframe.to_arrow()\n    # edges_table_augmented = augment_edges_table_with_weights(edges_arrow_dataframe)\n\n    # # TODO: also index the other columns?\n    # edges_data_schema = create_sqlite_schema_data_from_arrow_table(\n    #     table=edges_arrow_dataframe,\n    #     index_columns=[SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME],\n    #     column_map=edges_column_map,\n    # )\n\n    nodes_arrow_table = nodes_arrow_dataframe.to_arrow()\n\n    job_log.add_log(\"creating network data instance\")\n    network_data = NetworkData.create_network_data(\n        nodes_table=nodes_arrow_table, edges_table=edges_arrow_table\n    )\n\n    outputs.set_value(\"network_data\", network_data)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/create/#kiara_plugin.network_analysis.modules.create-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filter/","title":"filter","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule","title":"<code>NetworkDataFiltersModule</code>","text":"<p>               Bases: <code>FilterModule</code></p> Source code in <code>src/kiara_plugin/network_analysis/modules/filter.py</code> <pre><code>class NetworkDataFiltersModule(FilterModule):\n    _module_type_name = \"network_data.filters\"\n\n    @classmethod\n    def retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n        return \"network_data\"\n\n    def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n        if filter_name == \"select_component\":\n            return {\n                \"component_id\": {\n                    \"type\": \"integer\",\n                    \"doc\": \"The id of the componen to select.\",\n                    \"optional\": False,\n                    \"default\": 0,\n                },\n            }\n        return None\n\n    def filter__select_component(self, value: Value, filter_inputs: Mapping[str, Any]):\n        import duckdb\n\n        component_id = filter_inputs[\"component_id\"]\n\n        network_data: NetworkData = value.data\n\n        nodes_table = network_data.nodes.arrow_table\n\n        # Get non-computed node columns (excluding internal columns starting with '_')\n        nodes_table_columns = [LABEL_COLUMN_NAME]\n        for column_name in nodes_table.column_names:\n            if column_name.startswith(\"_\"):\n                continue\n            nodes_table_columns.append(f'\"{column_name}\"')\n\n        # Filter nodes by component and add a new sequential index\n        nodes_query = f\"\"\"\n            SELECT\n                ROW_NUMBER() OVER (ORDER BY {NODE_ID_COLUMN_NAME}) - 1 AS {NODE_ID_COLUMN_NAME},\n                {NODE_ID_COLUMN_NAME} AS old_node_id,\n                {\", \".join(nodes_table_columns)}  -- exclude NODE_ID_COLUMN_NAME since we're creating new_node_id\n            FROM nodes_table\n            WHERE {COMPONENT_ID_COLUMN_NAME} = {component_id}\n            ORDER BY {NODE_ID_COLUMN_NAME}\n        \"\"\"\n        nodes_result = duckdb.sql(nodes_query)\n\n        # Create a mapping table for old_node_id -&gt; new_node_id\n        id_mapping_query = f\"\"\"\n            SELECT old_node_id, {NODE_ID_COLUMN_NAME} FROM nodes_result\n        \"\"\"\n        id_mapping_result = duckdb.sql(id_mapping_query)  # noqa\n\n        # Get non-computed edge columns (excluding internal columns starting with '_')\n        edges_table = network_data.edges.arrow_table\n        edges_table_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n        for column_name in edges_table.column_names:\n            if column_name.startswith(\"_\"):\n                continue\n            edges_table_columns.append(f'\"{column_name}\"')\n\n        # Filter edges by component and translate node IDs using the mapping\n        edges_query = f\"\"\"\n            SELECT\n                src_map.{NODE_ID_COLUMN_NAME} AS {SOURCE_COLUMN_NAME},\n                e.{SOURCE_COLUMN_NAME} AS old_source_id,\n                tgt_map.{NODE_ID_COLUMN_NAME} AS {TARGET_COLUMN_NAME},\n                e.{TARGET_COLUMN_NAME} AS old_target_id\n                {\", \" + \", \".join(edges_table_columns[2:]) if len(edges_table_columns) &gt; 2 else \"\"}\n            FROM edges_table e\n            JOIN id_mapping_result src_map ON e.{SOURCE_COLUMN_NAME} = src_map.old_node_id\n            JOIN id_mapping_result tgt_map ON e.{TARGET_COLUMN_NAME} = tgt_map.old_node_id\n            WHERE e.{COMPONENT_ID_COLUMN_NAME} = {component_id}\n        \"\"\"\n        edges_result = duckdb.sql(edges_query)\n\n        network_data_result = NetworkData.create_network_data(\n            nodes_table=nodes_result.arrow(), edges_table=edges_result.arrow()\n        )\n\n        return network_data_result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule.retrieve_supported_type","title":"<code>retrieve_supported_type() -&gt; Union[Dict[str, Any], str]</code>  <code>classmethod</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/filter.py</code> <pre><code>@classmethod\ndef retrieve_supported_type(cls) -&gt; Union[Dict[str, Any], str]:\n    return \"network_data\"\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule.create_filter_inputs","title":"<code>create_filter_inputs(filter_name: str) -&gt; Union[None, ValueMapSchema]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/filter.py</code> <pre><code>def create_filter_inputs(self, filter_name: str) -&gt; Union[None, ValueMapSchema]:\n    if filter_name == \"select_component\":\n        return {\n            \"component_id\": {\n                \"type\": \"integer\",\n                \"doc\": \"The id of the componen to select.\",\n                \"optional\": False,\n                \"default\": 0,\n            },\n        }\n    return None\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/modules/filter/#kiara_plugin.network_analysis.modules.filter.NetworkDataFiltersModule.filter__select_component","title":"<code>filter__select_component(value: Value, filter_inputs: Mapping[str, Any])</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/modules/filter.py</code> <pre><code>def filter__select_component(self, value: Value, filter_inputs: Mapping[str, Any]):\n    import duckdb\n\n    component_id = filter_inputs[\"component_id\"]\n\n    network_data: NetworkData = value.data\n\n    nodes_table = network_data.nodes.arrow_table\n\n    # Get non-computed node columns (excluding internal columns starting with '_')\n    nodes_table_columns = [LABEL_COLUMN_NAME]\n    for column_name in nodes_table.column_names:\n        if column_name.startswith(\"_\"):\n            continue\n        nodes_table_columns.append(f'\"{column_name}\"')\n\n    # Filter nodes by component and add a new sequential index\n    nodes_query = f\"\"\"\n        SELECT\n            ROW_NUMBER() OVER (ORDER BY {NODE_ID_COLUMN_NAME}) - 1 AS {NODE_ID_COLUMN_NAME},\n            {NODE_ID_COLUMN_NAME} AS old_node_id,\n            {\", \".join(nodes_table_columns)}  -- exclude NODE_ID_COLUMN_NAME since we're creating new_node_id\n        FROM nodes_table\n        WHERE {COMPONENT_ID_COLUMN_NAME} = {component_id}\n        ORDER BY {NODE_ID_COLUMN_NAME}\n    \"\"\"\n    nodes_result = duckdb.sql(nodes_query)\n\n    # Create a mapping table for old_node_id -&gt; new_node_id\n    id_mapping_query = f\"\"\"\n        SELECT old_node_id, {NODE_ID_COLUMN_NAME} FROM nodes_result\n    \"\"\"\n    id_mapping_result = duckdb.sql(id_mapping_query)  # noqa\n\n    # Get non-computed edge columns (excluding internal columns starting with '_')\n    edges_table = network_data.edges.arrow_table\n    edges_table_columns = [SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME]\n    for column_name in edges_table.column_names:\n        if column_name.startswith(\"_\"):\n            continue\n        edges_table_columns.append(f'\"{column_name}\"')\n\n    # Filter edges by component and translate node IDs using the mapping\n    edges_query = f\"\"\"\n        SELECT\n            src_map.{NODE_ID_COLUMN_NAME} AS {SOURCE_COLUMN_NAME},\n            e.{SOURCE_COLUMN_NAME} AS old_source_id,\n            tgt_map.{NODE_ID_COLUMN_NAME} AS {TARGET_COLUMN_NAME},\n            e.{TARGET_COLUMN_NAME} AS old_target_id\n            {\", \" + \", \".join(edges_table_columns[2:]) if len(edges_table_columns) &gt; 2 else \"\"}\n        FROM edges_table e\n        JOIN id_mapping_result src_map ON e.{SOURCE_COLUMN_NAME} = src_map.old_node_id\n        JOIN id_mapping_result tgt_map ON e.{TARGET_COLUMN_NAME} = tgt_map.old_node_id\n        WHERE e.{COMPONENT_ID_COLUMN_NAME} = {component_id}\n    \"\"\"\n    edges_result = duckdb.sql(edges_query)\n\n    network_data_result = NetworkData.create_network_data(\n        nodes_table=nodes_result.arrow(), edges_table=edges_result.arrow()\n    )\n\n    return network_data_result\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/pipelines/__init__/","title":"pipelines","text":"<p>Default (empty) module that is used as a base path for pipelines contained in this package.</p>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/","title":"utils","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.extract_networkx_nodes_as_table","title":"<code>extract_networkx_nodes_as_table(graph: nx.Graph, label_attr_name: Union[str, None, Iterable[str]] = None, ignore_attributes: Union[None, Iterable[str]] = None) -&gt; Tuple[pa.Table, Dict[Hashable, int]]</code>","text":"<p>Extract the nodes of a networkx graph as a pyarrow table.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>the networkx graph</p> required <code>label_attr_name</code> <code>Union[str, None, Iterable[str]]</code> <p>the name of the node attribute that should be used as label. If None, the node id is used.</p> <code>None</code> <code>ignore_attributes</code> <code>Union[None, Iterable[str]]</code> <p>a list of node attributes that should be ignored and not added to the table</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Table, Dict[Hashable, int]]</code> <p>a tuple with the table and a map containing the original node id as key and the newly created internal node id (int) as value</p> Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def extract_networkx_nodes_as_table(\n    graph: \"nx.Graph\",\n    label_attr_name: Union[str, None, Iterable[str]] = None,\n    ignore_attributes: Union[None, Iterable[str]] = None,\n) -&gt; Tuple[\"pa.Table\", Dict[Hashable, int]]:\n    \"\"\"Extract the nodes of a networkx graph as a pyarrow table.\n\n    Arguments:\n        graph: the networkx graph\n        label_attr_name: the name of the node attribute that should be used as label. If None, the node id is used.\n        ignore_attributes: a list of node attributes that should be ignored and not added to the table\n\n    Returns:\n        a tuple with the table and a map containing the original node id as key and the newly created internal node id (int) as value\n    \"\"\"\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import pyarrow as pa\n\n    # nan = float(\"nan\")\n\n    nodes: Dict[str, List[Any]] = {\n        NODE_ID_COLUMN_NAME: [],\n        LABEL_COLUMN_NAME: [],\n    }\n    nodes_map = {}\n\n    for i, (node_id, node_data) in enumerate(graph.nodes(data=True)):\n        nodes[NODE_ID_COLUMN_NAME].append(i)\n        if label_attr_name is None:\n            nodes[LABEL_COLUMN_NAME].append(str(node_id))\n        elif isinstance(label_attr_name, str):\n            label = node_data.get(label_attr_name, None)\n            if label:\n                nodes[LABEL_COLUMN_NAME].append(str(label))\n            else:\n                nodes[LABEL_COLUMN_NAME].append(str(node_id))\n        else:\n            label_final = None\n            for label in label_attr_name:\n                label_final = node_data.get(label, None)\n                if label_final:\n                    break\n            if not label_final:\n                label_final = node_id\n            nodes[LABEL_COLUMN_NAME].append(str(label_final))\n\n        nodes_map[node_id] = i\n        for k in node_data.keys():\n            if ignore_attributes and k in ignore_attributes:\n                continue\n\n            if k.startswith(\"_\"):\n                raise KiaraException(\n                    \"Graph contains node column name starting with '_'. This is reserved for internal use, and not allowed.\"\n                )\n\n            v = node_data.get(k, None)\n            nodes.setdefault(k, []).append(v)\n\n    nodes_table = pa.Table.from_pydict(mapping=nodes)\n\n    return nodes_table, nodes_map\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.extract_networkx_edges_as_table","title":"<code>extract_networkx_edges_as_table(graph: nx.Graph, node_id_map: Dict[Hashable, int]) -&gt; pa.Table</code>","text":"<p>Extract the edges of this graph as a pyarrow table.</p> <p>The provided <code>node_id_map</code> might be modified if a node id is not yet in the map.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>The graph to extract edges from.</p> required <code>node_id_map</code> <code>Dict[Hashable, int]</code> <p>A mapping from (original) node ids to (kiara-internal) (integer) node-ids.</p> required Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def extract_networkx_edges_as_table(\n    graph: \"nx.Graph\", node_id_map: Dict[Hashable, int]\n) -&gt; \"pa.Table\":\n    \"\"\"Extract the edges of this graph as a pyarrow table.\n\n    The provided `node_id_map` might be modified if a node id is not yet in the map.\n\n    Args:\n        graph: The graph to extract edges from.\n        node_id_map: A mapping from (original) node ids to (kiara-internal) (integer) node-ids.\n    \"\"\"\n\n    # adapted from networx code\n    # License: 3-clause BSD license\n    # Copyright (C) 2004-2022, NetworkX Developers\n\n    import pyarrow as pa\n\n    if node_id_map is None:\n        node_id_map = {}\n\n    # nan = float(\"nan\")\n\n    max_node_id = max(node_id_map.values())  # TODO: could we just use len(node_id_map)?\n    edge_columns: Dict[str, List[int]] = {\n        SOURCE_COLUMN_NAME: [],\n        TARGET_COLUMN_NAME: [],\n    }\n\n    for source, target, edge_data in graph.edges(data=True):\n        if source not in node_id_map.keys():\n            max_node_id += 1\n            node_id_map[source] = max_node_id\n        if target not in node_id_map.keys():\n            max_node_id += 1\n            node_id_map[target] = max_node_id\n\n        edge_columns[SOURCE_COLUMN_NAME].append(node_id_map[source])\n        edge_columns[TARGET_COLUMN_NAME].append(node_id_map[target])\n\n        for k in edge_data.keys():\n            if k.startswith(\"_\"):\n                raise KiaraException(\n                    \"Graph contains edge column name starting with '_'. This is reserved for internal use, and not allowed.\"\n                )\n\n            v = edge_data.get(k, None)\n            edge_columns.setdefault(k, []).append(v)  # type: ignore\n\n    edges_table = pa.Table.from_pydict(mapping=edge_columns)\n\n    return edges_table\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.augment_nodes_table_with_connection_counts","title":"<code>augment_nodes_table_with_connection_counts(nodes_table: Union[pa.Table, pl.DataFrame], edges_table: Union[pa.Table, pl.DataFrame]) -&gt; pa.Table</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def augment_nodes_table_with_connection_counts(\n    nodes_table: Union[\"pa.Table\", \"pl.DataFrame\"],\n    edges_table: Union[\"pa.Table\", \"pl.DataFrame\"],\n) -&gt; \"pa.Table\":\n    import duckdb\n\n    try:\n        nodes_column_names = nodes_table.column_names  # type: ignore\n    except Exception:\n        nodes_column_names = nodes_table.columns  # type: ignore\n\n    node_attr_columns = [f'\"{x}\"' for x in nodes_column_names if not x.startswith(\"_\")]\n    if node_attr_columns:\n        other_columns = \", \" + \", \".join(node_attr_columns)\n    else:\n        other_columns = \"\"\n\n    # we can avoid 'COUNT(*)' calls in the following  query\n    nodes_table_rows = len(nodes_table)\n\n    query = f\"\"\"\n    SELECT\n         {NODE_ID_COLUMN_NAME},\n         {LABEL_COLUMN_NAME},\n         COALESCE(e1.{IN_DIRECTED_COLUMN_NAME}, 0) + COALESCE(e3.{OUT_DIRECTED_COLUMN_NAME}, 0) as {CONNECTIONS_COLUMN_NAME},\n         (COALESCE(e1._in_edges, 0) + COALESCE(e3._out_edges, 0)) / {nodes_table_rows} AS _degree_centrality,\n         COALESCE(e2.{IN_DIRECTED_MULTI_COLUMN_NAME}, 0) + COALESCE(e4.{OUT_DIRECTED_MULTI_COLUMN_NAME}, 0) as {CONNECTIONS_MULTI_COLUMN_NAME},\n         COALESCE(e1.{IN_DIRECTED_COLUMN_NAME}, 0) as {IN_DIRECTED_COLUMN_NAME},\n         COALESCE(e2.{IN_DIRECTED_MULTI_COLUMN_NAME}, 0) as {IN_DIRECTED_MULTI_COLUMN_NAME},\n         COALESCE(e3.{OUT_DIRECTED_COLUMN_NAME}, 0) as {OUT_DIRECTED_COLUMN_NAME},\n         COALESCE(e4.{OUT_DIRECTED_MULTI_COLUMN_NAME}, 0) as {OUT_DIRECTED_MULTI_COLUMN_NAME}\n         {other_columns}\n         FROM nodes_table n\n         left join\n           (SELECT {TARGET_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}, COUNT(*) as {IN_DIRECTED_COLUMN_NAME} from edges_table GROUP BY {TARGET_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}) e1\n           on n.{NODE_ID_COLUMN_NAME} = e1.{TARGET_COLUMN_NAME} and e1.{COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\n         left join\n           (SELECT {TARGET_COLUMN_NAME}, COUNT(*) as {IN_DIRECTED_MULTI_COLUMN_NAME} from edges_table GROUP BY {TARGET_COLUMN_NAME}) e2\n           on n.{NODE_ID_COLUMN_NAME} = e2.{TARGET_COLUMN_NAME}\n         left join\n           (SELECT {SOURCE_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}, COUNT(*) as {OUT_DIRECTED_COLUMN_NAME} from edges_table GROUP BY {SOURCE_COLUMN_NAME}, {COUNT_IDX_DIRECTED_COLUMN_NAME}) e3\n           on n.{NODE_ID_COLUMN_NAME} = e3.{SOURCE_COLUMN_NAME} and e3.{COUNT_IDX_DIRECTED_COLUMN_NAME} = 1\n         left join\n           (SELECT {SOURCE_COLUMN_NAME}, COUNT(*) as {OUT_DIRECTED_MULTI_COLUMN_NAME} from edges_table GROUP BY {SOURCE_COLUMN_NAME}) e4\n           on n.{NODE_ID_COLUMN_NAME} = e4.{SOURCE_COLUMN_NAME}\n        ORDER BY {NODE_ID_COLUMN_NAME}\n    \"\"\"\n    nodes_table_result = duckdb.sql(query)  # noqa\n\n    centrality_query = f\"\"\"\n    SELECT\n         {NODE_ID_COLUMN_NAME},\n         {LABEL_COLUMN_NAME},\n         {CONNECTIONS_COLUMN_NAME},\n         {CONNECTIONS_COLUMN_NAME} / (SELECT COUNT(*) FROM nodes_table_result) AS {UNWEIGHTED_DEGREE_CENTRALITY_COLUMN_NAME},\n         {CONNECTIONS_MULTI_COLUMN_NAME},\n         {CONNECTIONS_MULTI_COLUMN_NAME} / (SELECT COUNT(*) FROM nodes_table_result) AS {UNWEIGHTED_DEGREE_CENTRALITY_MULTI_COLUMN_NAME},\n         {IN_DIRECTED_COLUMN_NAME},\n         {IN_DIRECTED_MULTI_COLUMN_NAME},\n         {OUT_DIRECTED_COLUMN_NAME},\n         {OUT_DIRECTED_MULTI_COLUMN_NAME}\n         {other_columns}\n    FROM nodes_table_result\n    \"\"\"\n\n    result = duckdb.sql(centrality_query)\n\n    nodes_table_augmented = result.arrow()\n    return nodes_table_augmented\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.augment_edges_table_with_id_and_weights","title":"<code>augment_edges_table_with_id_and_weights(edges_table: Union[pa.Table, pl.DataFrame]) -&gt; pa.Table</code>","text":"<p>Augment the edges table with additional pre-computed columns for directed and undirected weights..</p> Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def augment_edges_table_with_id_and_weights(\n    edges_table: Union[\"pa.Table\", \"pl.DataFrame\"],\n) -&gt; \"pa.Table\":\n    \"\"\"Augment the edges table with additional pre-computed columns for directed and undirected weights..\"\"\"\n\n    import duckdb\n\n    try:\n        column_names = edges_table.column_names  # type: ignore\n    except Exception:\n        column_names = edges_table.columns  # type: ignore\n\n    edge_attr_columns = [f'\"{x}\"' for x in column_names if not x.startswith(\"_\")]\n    if edge_attr_columns:\n        other_columns = \", \" + \", \".join(edge_attr_columns)\n    else:\n        other_columns = \"\"\n\n    query = f\"\"\"\n    SELECT\n      ROW_NUMBER() OVER () -1 as {EDGE_ID_COLUMN_NAME},\n      {SOURCE_COLUMN_NAME},\n      {TARGET_COLUMN_NAME},\n      COUNT(*) OVER (PARTITION BY {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}) as {COUNT_DIRECTED_COLUMN_NAME},\n      ROW_NUMBER(*) OVER (PARTITION BY {SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}) as {COUNT_IDX_DIRECTED_COLUMN_NAME},\n      COUNT(*) OVER (PARTITION BY LEAST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}), GREATEST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME})) as {COUNT_UNDIRECTED_COLUMN_NAME},\n      ROW_NUMBER(*) OVER (PARTITION BY LEAST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME}), GREATEST({SOURCE_COLUMN_NAME}, {TARGET_COLUMN_NAME})) as {COUNT_IDX_UNDIRECTED_COLUMN_NAME}\n      {other_columns}\n    FROM edges_table\"\"\"\n\n    result = duckdb.sql(query)\n    edges_table_augmented = result.arrow()\n\n    return edges_table_augmented\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.augment_tables_with_component_ids","title":"<code>augment_tables_with_component_ids(nodes_table: pa.Table, edges_table: pa.Table) -&gt; Tuple[pa.Table, pa.Table]</code>","text":"<p>Augment the nodes and edges table with a component id column.</p> <p>The component id is a unique id for each connected component in the graph. The id of thte component is assigned in a deterministic way, based on the size of the components. The largest component gets id 0, the second largest 1, and so on.</p> <p>Should 2 components have the same amount of nodes, the component id is not deterministic anymore.</p> Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def augment_tables_with_component_ids(\n    nodes_table: \"pa.Table\", edges_table: \"pa.Table\"\n) -&gt; Tuple[\"pa.Table\", \"pa.Table\"]:\n    \"\"\"Augment the nodes and edges table with a component id column.\n\n    The component id is a unique id for each connected component in the graph. The id of thte component is\n    assigned in a deterministic way, based on the size of the components. The largest component gets id 0, the\n    second largest 1, and so on.\n\n    Should 2 components have the same amount of nodes, the component id is not deterministic anymore.\n    \"\"\"\n\n    import polars as pl\n    import pyarrow as pa\n    import rustworkx as rx\n\n    # create rustworkx graph\n    graph = rx.PyGraph(multigraph=False)\n\n    nodes_df: DataFrame = pl.from_arrow(nodes_table)  # type: ignore\n    for row in nodes_df.select(NODE_ID_COLUMN_NAME).rows(named=True):\n        node_id = row[NODE_ID_COLUMN_NAME]\n        graph_node_id = graph.add_node(node_id)\n        assert node_id == graph_node_id\n\n    edges_df: DataFrame = pl.from_arrow(edges_table)  # type: ignore\n    for row in edges_df.select(SOURCE_COLUMN_NAME, TARGET_COLUMN_NAME).rows(named=True):\n        if row[SOURCE_COLUMN_NAME] == row[TARGET_COLUMN_NAME]:\n            continue\n\n        source_id = row[SOURCE_COLUMN_NAME]\n        target_id = row[TARGET_COLUMN_NAME]\n\n        graph.add_edge(source_id, target_id, None)\n\n    components = rx.connected_components(graph)\n    nodes_idx = 0\n    for col_name in nodes_table.column_names:\n        if col_name.startswith(\"_\"):\n            nodes_idx += 1\n            continue\n\n    if len(components) == 1:\n        components_column_nodes = pa.array([0] * len(nodes_table), type=pa.int64())\n        nodes = nodes_table.add_column(\n            nodes_idx, COMPONENT_ID_COLUMN_NAME, components_column_nodes\n        )\n        components_column_edges = pa.array([0] * len(edges_table), type=pa.int64())\n\n        edges_idx = 0\n        for col_name in edges_table.column_names:\n            if col_name.startswith(\"_\"):\n                edges_idx += 1\n                continue\n        edges = edges_table.add_column(\n            edges_idx, COMPONENT_ID_COLUMN_NAME, components_column_edges\n        )\n        return nodes, edges\n\n    node_components = {}\n    for idx, component in enumerate(sorted(components, key=len, reverse=True)):\n        for node_id in component:\n            node_components[node_id] = idx\n\n    if len(node_components) != graph.num_nodes():\n        raise KiaraException(\n            \"Number of nodes in component map does not match number of nodes in network data. This is most likely a bug.\"\n        )\n\n    components_column_nodes = pa.array(\n        (node_components[node_id] for node_id in sorted(node_components.keys())),\n        type=pa.int64(),\n    )\n    nodes = nodes_table.add_column(\n        nodes_idx, COMPONENT_ID_COLUMN_NAME, components_column_nodes\n    )\n\n    try:\n        column_names = edges_table.column_names  # type: ignore\n    except Exception:\n        column_names = edges_table.columns  # type: ignore\n\n    computed_attr_columns = [x for x in column_names if x.startswith(\"_\")]\n    computed_columns = \", \".join(computed_attr_columns)\n    edge_attr_columns = [x for x in column_names if not x.startswith(\"_\")]\n    if edge_attr_columns:\n        other_columns = \", \" + \", \".join(edge_attr_columns)\n    else:\n        other_columns = \"\"\n\n    # a query that looks up the value of a SOURCE_COLUMN_NAME in edges_table in the\n    # NODE_ID_COLUMN_NAME of nodes, and returns the component id from the nodes table\n    query = f\"\"\"\n    SELECT\n        {computed_columns},\n        n.{COMPONENT_ID_COLUMN_NAME} as {COMPONENT_ID_COLUMN_NAME}\n        {other_columns}\n    FROM edges_table e\n    JOIN nodes n ON e.{SOURCE_COLUMN_NAME} = n.{NODE_ID_COLUMN_NAME}\n    \"\"\"\n\n    edges = duckdb.sql(query)\n\n    return nodes, edges.arrow()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.extract_network_data","title":"<code>extract_network_data(network_data: Union[Value, NetworkData]) -&gt; NetworkData</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def extract_network_data(network_data: Union[\"Value\", \"NetworkData\"]) -&gt; \"NetworkData\":\n    from kiara.models.values.value import Value\n\n    if isinstance(network_data, Value):\n        assert network_data.data_type_name == \"network_data\"\n        network_data = network_data.data\n    return network_data  # type: ignore\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.guess_column_name","title":"<code>guess_column_name(table: Union[pa.Table, KiaraTable, Value], suggestions: List[str]) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_column_name(\n    table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"], suggestions: List[str]\n) -&gt; Union[str, None]:\n    column_names: Union[List[str], None] = None\n\n    if hasattr(table, \"column_names\"):\n        column_names = table.column_names\n    else:\n        from kiara.models.values.value import Value\n\n        if isinstance(table, Value):\n            table_instance = table.data\n            if hasattr(table_instance, \"column_names\"):\n                column_names = table_instance.column_names\n\n    if not column_names:\n        return None\n\n    for suggestion in suggestions:\n        if suggestion in column_names:\n            return suggestion\n\n    for suggestion in suggestions:\n        for column_name in column_names:\n            if suggestion.lower() == column_name.lower():\n                return column_name\n\n    return None\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.guess_node_id_column_name","title":"<code>guess_node_id_column_name(nodes_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_node_id_column_name(\n    nodes_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = NODE_ID_ALIAS_NAMES\n    return guess_column_name(table=nodes_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.guess_node_label_column_name","title":"<code>guess_node_label_column_name(nodes_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_node_label_column_name(\n    nodes_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = LABEL_ALIAS_NAMES\n    return guess_column_name(table=nodes_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.guess_source_column_name","title":"<code>guess_source_column_name(edges_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_source_column_name(\n    edges_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = SOURCE_COLUMN_ALIAS_NAMES\n    return guess_column_name(table=edges_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/__init__/#kiara_plugin.network_analysis.utils.guess_target_column_name","title":"<code>guess_target_column_name(edges_table: Union[pa.Table, KiaraTable, Value], suggestions: Union[None, List[str]] = None) -&gt; Union[str, None]</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/__init__.py</code> <pre><code>def guess_target_column_name(\n    edges_table: Union[\"pa.Table\", \"KiaraTable\", \"Value\"],\n    suggestions: Union[None, List[str]] = None,\n) -&gt; Union[str, None]:\n    if suggestions is None:\n        suggestions = TARGET_COLUMN_ALIAS_NAMES\n    return guess_column_name(table=edges_table, suggestions=suggestions)\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/__init__/","title":"notebooks","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/","title":"jupyter","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter.prepare_mpl_graph_jupyter","title":"<code>prepare_mpl_graph_jupyter(network_data: Union[Value, NetworkData, None])</code>","text":"<p>Prepare matplotlib graph for Jupyter notebook.</p> Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/jupyter.py</code> <pre><code>def prepare_mpl_graph_jupyter(network_data: Union[Value, NetworkData, None]):\n    \"\"\"Prepare matplotlib graph for Jupyter notebook.\"\"\"\n    from matplotlib import pyplot as plt\n\n    plt.figure(figsize=(10, 8))\n\n    if network_data is not None:\n        network_data = extract_network_data(network_data)\n        graph = network_data.as_rustworkx_graph(\n            rx.PyGraph, incl_node_attributes=[LABEL_COLUMN_NAME]\n        )\n        mpl_draw(graph, with_labels=True, labels=lambda node: node[LABEL_COLUMN_NAME])  # type: ignore\n        plt.title(\"Network Graph (Matplotlib + RustWorkX)\")\n    else:\n        plt.text(\n            0.5,\n            0.5,\n            \"No graph data available\",\n            horizontalalignment=\"center\",\n            verticalalignment=\"center\",\n        )\n        plt.title(\"No Network Data\")\n\n    plt.axis(\"off\")\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter.prepare_plotly_graph_jupyter","title":"<code>prepare_plotly_graph_jupyter(network_data: Union[Value, NetworkData, None])</code>","text":"<p>Prepare Plotly graph for Jupyter notebook.</p> Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/jupyter.py</code> <pre><code>def prepare_plotly_graph_jupyter(network_data: Union[Value, NetworkData, None]):\n    \"\"\"Prepare Plotly graph for Jupyter notebook.\"\"\"\n    if network_data is None:\n        return None\n\n    import plotly.graph_objects as go\n\n    # Get the rustworkx graph\n    network_data = extract_network_data(network_data)\n    rx_graph = network_data.as_rustworkx_graph(\n        rx.PyGraph, incl_node_attributes=[LABEL_COLUMN_NAME]\n    )\n\n    # Get node positions using spring layout\n    pos = rx.spring_layout(rx_graph, seed=42)\n\n    # Extract node coordinates\n    node_x = [pos[node][0] for node in rx_graph.node_indices()]\n    node_y = [pos[node][1] for node in rx_graph.node_indices()]\n\n    # Get node labels/info\n    node_info = [\n        rx_graph.get_node_data(i)[LABEL_COLUMN_NAME] for i in rx_graph.node_indices()\n    ]\n\n    # Extract edge coordinates\n    edge_x = []\n    edge_y = []\n    for edge in rx_graph.edge_list():\n        x0, y0 = pos[edge[0]]\n        x1, y1 = pos[edge[1]]\n        edge_x.extend([x0, x1, None])\n        edge_y.extend([y0, y1, None])\n\n    # Create edge trace\n    edge_trace = go.Scatter(\n        x=edge_x,\n        y=edge_y,\n        line={\"width\": 0.5, \"color\": \"#888\"},\n        hoverinfo=\"none\",\n        mode=\"lines\",\n    )\n\n    # Create node trace\n    node_trace = go.Scatter(\n        x=node_x,\n        y=node_y,\n        mode=\"markers\",\n        hoverinfo=\"text\",\n        text=node_info,\n        marker={\n            \"showscale\": True,\n            \"colorscale\": \"YlGnBu\",\n            \"reversescale\": True,\n            \"color\": [],\n            \"size\": 10,\n            \"colorbar\": {\n                \"thickness\": 15,\n                \"len\": 0.5,\n                \"x\": 1.02,\n                \"title\": \"Node Connections\",\n            },\n            \"line\": {\"width\": 2},\n        },\n    )\n\n    # Color nodes by number of connections\n    node_adjacencies = []\n    for node in rx_graph.node_indices():\n        adjacencies = len(list(rx_graph.neighbors(node)))\n        node_adjacencies.append(adjacencies)\n\n    node_trace.marker.color = node_adjacencies\n\n    # Create the figure\n    fig = go.Figure(\n        data=[edge_trace, node_trace],\n        layout=go.Layout(\n            title={\n                \"text\": \"Interactive Network Graph (RustWorkX + Plotly)\",\n                \"font\": {\"size\": 16},\n            },\n            showlegend=False,\n            hovermode=\"closest\",\n            margin={\"b\": 20, \"l\": 5, \"r\": 5, \"t\": 40},\n            annotations=[\n                {\n                    \"text\": \"Hover over nodes to see details\",\n                    \"showarrow\": False,\n                    \"xref\": \"paper\",\n                    \"yref\": \"paper\",\n                    \"x\": 0.005,\n                    \"y\": -0.002,\n                    \"xanchor\": \"left\",\n                    \"yanchor\": \"bottom\",\n                    \"font\": {\"color\": \"#888\", \"size\": 12},\n                }\n            ],\n            xaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\n            yaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\n        ),\n    )\n\n    return fig\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/jupyter/#kiara_plugin.network_analysis.utils.notebooks.jupyter.prepare_altair_graph_jupyter","title":"<code>prepare_altair_graph_jupyter(network_data: Union[Value, NetworkData, None])</code>","text":"<p>Prepare Altair graph for Jupyter notebook.</p> Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/jupyter.py</code> <pre><code>def prepare_altair_graph_jupyter(network_data: Union[Value, NetworkData, None]):\n    \"\"\"Prepare Altair graph for Jupyter notebook.\"\"\"\n    if network_data is None:\n        return None\n\n    import altair as alt\n    import pandas as pd\n\n    network_data = extract_network_data(network_data)\n    # Get the rustworkx graph with node attributes (including labels)\n    rx_graph = network_data.as_rustworkx_graph(rx.PyGraph, incl_node_attributes=True)\n\n    # Get node positions using spring layout\n    pos = rx.spring_layout(rx_graph, seed=42)\n\n    # Create nodes dataframe\n    nodes_data = []\n    for node_idx in rx_graph.node_indices():\n        node_data = rx_graph[node_idx]\n        label = node_data.get(\"_label\", f\"Node {node_idx}\")\n        degree = len(list(rx_graph.neighbors(node_idx)))\n\n        nodes_data.append(\n            {\n                \"node_id\": node_idx,\n                \"x\": pos[node_idx][0],\n                \"y\": pos[node_idx][1],\n                \"label\": label,\n                \"degree\": degree,\n                \"original_id\": node_data.get(\"_node_id\", node_idx),\n            }\n        )\n\n    nodes_df = pd.DataFrame(nodes_data)\n\n    # Create edges dataframe\n    edges_data = []\n    for edge in rx_graph.edge_list():\n        source_pos = pos[edge[0]]\n        target_pos = pos[edge[1]]\n\n        edges_data.append(\n            {\n                \"source\": edge[0],\n                \"target\": edge[1],\n                \"x\": source_pos[0],\n                \"y\": source_pos[1],\n                \"x2\": target_pos[0],\n                \"y2\": target_pos[1],\n            }\n        )\n\n    edges_df = pd.DataFrame(edges_data)\n\n    # Create edges layer\n    edges_chart = (\n        alt.Chart(edges_df)\n        .mark_rule(color=\"lightgray\", strokeWidth=1, opacity=0.6)\n        .encode(\n            x=alt.X(\"x:Q\", scale=alt.Scale(nice=False), axis=None),\n            y=alt.Y(\"y:Q\", scale=alt.Scale(nice=False), axis=None),\n            x2=\"x2:Q\",\n            y2=\"y2:Q\",\n        )\n    )\n\n    # Create nodes layer with selection\n    click_selection = alt.selection_point(fields=[\"node_id\"], toggle=True)\n\n    nodes_chart = (\n        alt.Chart(nodes_df)\n        .mark_circle(size=100, stroke=\"white\", strokeWidth=2)\n        .encode(\n            x=alt.X(\"x:Q\", scale=alt.Scale(nice=False), axis=None),\n            y=alt.Y(\"y:Q\", scale=alt.Scale(nice=False), axis=None),\n            color=alt.Color(\n                \"degree:Q\",\n                scale=alt.Scale(scheme=\"viridis\"),\n                legend=alt.Legend(title=\"Node Degree\"),\n            ),\n            size=alt.Size(\n                \"degree:Q\",\n                scale=alt.Scale(range=[50, 200]),\n                legend=alt.Legend(title=\"Node Degree\"),\n            ),\n            opacity=alt.condition(click_selection, alt.value(1.0), alt.value(0.7)),\n            stroke=alt.condition(click_selection, alt.value(\"red\"), alt.value(\"white\")),\n            strokeWidth=alt.condition(click_selection, alt.value(3), alt.value(1)),\n            tooltip=[\"label:N\", \"original_id:O\", \"degree:Q\"],\n        )\n        .add_params(click_selection)\n    )\n\n    # Combine layers\n    chart = (\n        (edges_chart + nodes_chart)\n        .resolve_scale(color=\"independent\")\n        .properties(\n            width=600,\n            height=400,\n            title=\"Interactive Network Graph (RustWorkX + Altair)\",\n        )\n        .interactive()\n    )\n\n    return chart\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/","title":"marimo","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo-attributes","title":"Attributes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo-classes","title":"Classes","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo-functions","title":"Functions","text":""},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo.prepare_mpl_graph","title":"<code>prepare_mpl_graph(network_data: Union[Value, NetworkData, None])</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/marimo.py</code> <pre><code>def prepare_mpl_graph(network_data: Union[\"Value\", \"NetworkData\", None]):\n    import matplotlib.pyplot as plt\n    import rustworkx as rx\n    from rustworkx.visualization import mpl_draw\n\n    plt.figure()\n\n    if network_data is not None:\n        network_data = extract_network_data(network_data)\n        graph = network_data.as_rustworkx_graph(\n            rx.PyGraph, incl_node_attributes=[LABEL_COLUMN_NAME]\n        )\n        mpl_draw(graph, with_labels=True, labels=lambda node: node[LABEL_COLUMN_NAME])  # type: ignore\n    else:\n        # Create an empty plot or placeholder\n        plt.text(\n            0.5,\n            0.5,\n            \"No graph data available\",\n            horizontalalignment=\"center\",\n            verticalalignment=\"center\",\n        )\n\n    chart_mpl = mo.mpl.interactive(plt.gcf())\n    return chart_mpl\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo.prepare_altair_graph","title":"<code>prepare_altair_graph(network_data: Union[Value, NetworkData, None])</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/marimo.py</code> <pre><code>def prepare_altair_graph(network_data: Union[\"Value\", \"NetworkData\", None]):\n    import altair as alt\n    import pandas as pd\n\n    if network_data is None:\n        return None\n\n    network_data = extract_network_data(network_data)\n    # Get the rustworkx graph with node attributes (including labels)\n    rx_graph = network_data.as_rustworkx_graph(rx.PyGraph, incl_node_attributes=True)\n\n    # Get node positions using spring layout\n    pos = rx.spring_layout(rx_graph, seed=42)\n\n    # Create nodes dataframe\n    nodes_data = []\n    for node_idx in rx_graph.node_indices():\n        node_data = rx_graph[node_idx]\n        label = node_data.get(\"_label\", f\"Node {node_idx}\")\n        degree = len(list(rx_graph.neighbors(node_idx)))\n\n        nodes_data.append(\n            {\n                \"node_id\": node_idx,\n                \"x\": pos[node_idx][0],\n                \"y\": pos[node_idx][1],\n                \"label\": label,\n                \"degree\": degree,\n                \"original_id\": node_data.get(\"_node_id\", node_idx),\n            }\n        )\n\n    nodes_df = pd.DataFrame(nodes_data)\n\n    # Create edges dataframe\n    edges_data = []\n    for edge in rx_graph.edge_list():\n        source_pos = pos[edge[0]]\n        target_pos = pos[edge[1]]\n\n        edges_data.append(\n            {\n                \"source\": edge[0],\n                \"target\": edge[1],\n                \"x\": source_pos[0],\n                \"y\": source_pos[1],\n                \"x2\": target_pos[0],\n                \"y2\": target_pos[1],\n            }\n        )\n\n    edges_df = pd.DataFrame(edges_data)\n\n    # Create edges layer\n    edges_chart = (\n        alt.Chart(edges_df)\n        .mark_rule(color=\"lightgray\", strokeWidth=1, opacity=0.6)\n        .encode(\n            x=alt.X(\"x:Q\", scale=alt.Scale(nice=False), axis=None),\n            y=alt.Y(\"y:Q\", scale=alt.Scale(nice=False), axis=None),\n            x2=\"x2:Q\",\n            y2=\"y2:Q\",\n        )\n    )\n\n    # Create nodes layer with selection\n    click_selection = alt.selection_point(fields=[\"node_id\"], toggle=True)\n\n    nodes_chart = (\n        alt.Chart(nodes_df)\n        .mark_circle(size=100, stroke=\"white\", strokeWidth=2)\n        .encode(\n            x=alt.X(\"x:Q\", scale=alt.Scale(nice=False), axis=None),\n            y=alt.Y(\"y:Q\", scale=alt.Scale(nice=False), axis=None),\n            color=alt.Color(\n                \"degree:Q\",\n                scale=alt.Scale(scheme=\"viridis\"),\n                legend=alt.Legend(title=\"Node Degree\"),\n            ),\n            size=alt.Size(\n                \"degree:Q\",\n                scale=alt.Scale(range=[50, 200]),\n                legend=alt.Legend(title=\"Node Degree\"),\n            ),\n            opacity=alt.condition(click_selection, alt.value(1.0), alt.value(0.7)),\n            stroke=alt.condition(click_selection, alt.value(\"red\"), alt.value(\"white\")),\n            strokeWidth=alt.condition(click_selection, alt.value(3), alt.value(1)),\n            tooltip=[\"label:N\", \"original_id:O\", \"degree:Q\"],\n        )\n        .add_params(click_selection)\n    )\n\n    # Combine layers\n    chart = (\n        (edges_chart + nodes_chart)\n        .resolve_scale(color=\"independent\")\n        .properties(\n            width=600,\n            height=400,\n            title=\"Interactive Network Graph (RustWorkX + Altair)\",\n        )\n        .interactive()\n    )\n\n    # Use marimo's altair chart with selection support\n    chart = mo.ui.altair_chart(chart)\n\n    return chart\n</code></pre>"},{"location":"reference/kiara_plugin/network_analysis/utils/notebooks/marimo/#kiara_plugin.network_analysis.utils.notebooks.marimo.prepare_plotly_graph","title":"<code>prepare_plotly_graph(network_data: Union[Value, NetworkData, None])</code>","text":"Source code in <code>src/kiara_plugin/network_analysis/utils/notebooks/marimo.py</code> <pre><code>def prepare_plotly_graph(network_data: Union[\"Value\", \"NetworkData\", None]):\n    import plotly.graph_objects as go\n    import plotly.io as pio\n\n    if network_data is None:\n        return None\n\n    # Set plotly renderer for marimo compatibility\n    pio.renderers.default = \"json\"\n\n    # Get the rustworkx graph\n    network_data = extract_network_data(network_data)\n    rx_graph = network_data.as_rustworkx_graph(\n        rx.PyGraph, incl_node_attributes=[LABEL_COLUMN_NAME]\n    )\n\n    # Get node positions using spring layout\n    pos = rx.spring_layout(rx_graph, seed=42)\n\n    # Extract node coordinates\n    node_x = [pos[node][0] for node in rx_graph.node_indices()]\n    node_y = [pos[node][1] for node in rx_graph.node_indices()]\n\n    # Get node labels/info\n    node_info = [\n        rx_graph.get_node_data(i)[LABEL_COLUMN_NAME] for i in rx_graph.node_indices()\n    ]\n\n    # Extract edge coordinates\n    edge_x = []\n    edge_y = []\n    for edge in rx_graph.edge_list():\n        x0, y0 = pos[edge[0]]\n        x1, y1 = pos[edge[1]]\n        edge_x.extend([x0, x1, None])\n        edge_y.extend([y0, y1, None])\n\n    # Create edge trace\n    edge_trace = go.Scatter(\n        x=edge_x,\n        y=edge_y,\n        line={\"width\": 0.5, \"color\": \"#888\"},\n        hoverinfo=\"none\",\n        mode=\"lines\",\n    )\n\n    # Create node trace\n    node_trace = go.Scatter(\n        x=node_x,\n        y=node_y,\n        mode=\"markers\",\n        hoverinfo=\"text\",\n        text=node_info,\n        marker={\n            \"showscale\": True,\n            \"colorscale\": \"YlGnBu\",\n            \"reversescale\": True,\n            \"color\": [],\n            \"size\": 10,\n            \"colorbar\": {\n                \"thickness\": 15,\n                \"len\": 0.5,\n                \"x\": 1.02,\n                \"title\": \"Node Connections\",\n            },\n            \"line\": {\"width\": 2},\n        },\n    )\n\n    # Color nodes by number of connections\n    node_adjacencies = []\n    for node in rx_graph.node_indices():\n        adjacencies = len(list(rx_graph.neighbors(node)))\n        node_adjacencies.append(adjacencies)\n\n    node_trace.marker.color = node_adjacencies\n\n    # Create the figure\n    fig = go.Figure(\n        data=[edge_trace, node_trace],\n        layout=go.Layout(\n            title={\n                \"text\": \"Interactive Network Graph (RustWorkX + Plotly)\",\n                \"font\": {\"size\": 16},\n            },\n            showlegend=False,\n            hovermode=\"closest\",\n            margin={\"b\": 20, \"l\": 5, \"r\": 5, \"t\": 40},\n            annotations=[\n                {\n                    \"text\": \"Hover over nodes to see details\",\n                    \"showarrow\": False,\n                    \"xref\": \"paper\",\n                    \"yref\": \"paper\",\n                    \"x\": 0.005,\n                    \"y\": -0.002,\n                    \"xanchor\": \"left\",\n                    \"yanchor\": \"bottom\",\n                    \"font\": {\"color\": \"#888\", \"size\": 12},\n                }\n            ],\n            xaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\n            yaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\n        ),\n    )\n\n    return fig\n</code></pre>"}]}